<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="UserMode" Id="{dbb58c86-3204-4c0e-a297-03b24a68bd10}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM UserMode
VAR_INPUT
	UserGapPositionNew:LREAL:=20;//target
	UserGapVelocityNew:LREAL:=1;//target
		(**)
	btn_UserGapMove:BOOL;
	btn_UserGapStop:BOOL;
END_VAR
VAR	
	USE_SingleAxis_Compensation:BOOL:=TRUE;
(*GapMode*)

	UserGapPositionDisplay:LREAL;//current
	UserGapVelocityDisplay:LREAL;//current
	UserTaperPositionNew:LREAL:=0;//target
	UserTaperVelocityNew:LREAL:=0.1;//target
	UserTaperPositionDisplay:LREAL;//current
	UserTaperVelocityDisplay:LREAL;//target
	UserGapPositionDisplay_FromLeftTop:LREAL;
	UserGapPositionDisplay_FromLeftBottom:LREAL;
	UserGapPositionDisplay_FromLeftIn:LREAL;
	UserGapPositionDisplay_FromLeftOut:LREAL;
	//
	UserRightGapPositionNew:LREAL;
	UserRightGapVelocityNew:LREAL;
	UserRightGapPositionDisplay:LREAL;
	UserRightGapVelocityDisplay:LREAL;
	UserRightGapPositionDisplay_FromRightTop:LREAL;
	UserRightGapPositionDisplay_FromRightBottom:LREAL;
	UserRightGapPositionDisplay_FromRightIn:LREAL;
	UserRightGapPositionDisplay_FromRightOut:LREAL;

	(*Var*)
	fb_ton1:TON;
	fb_ton2:TON;
	fb_ton3:TON;
	fb_ton4:TON;
	fb_ton5:TON;
	fb_ton6:TON;
	(*Status*)
	State:DINT;
	Busy:BOOL;
	InitPowerDone:BOOL;
	InitCompensationDatasDone:BOOL;
	(*FB*)
	m_state: DINT;
	n_state: DINT;
	s_state: DINT;
	(*¼ì²âµ½ÏÞÎ»£¬»Ö¸´Move×´Ì¬*)
	FTrig_ReachLS: F_TRIG;
	FTrig_btn_GapMove: F_TRIG;
	GapOutRange: BOOL;
	(*PowerOff*)
	d_state: DINT;
	i: INT;
	j: INT;
	k: INT;
	moni_State:DINT;
	TargetPosLessThanCurrentPos:BOOL;
	TargetLTPosLessThanCurrentLTPos:BOOL;
	TargetRTPosLessThanCurrentRTPos:BOOL;
	TargetLBPosLessThanCurrentLBPos:BOOL;
	TargetRBPosLessThanCurrentRBPos:BOOL;
	TargetLIPosLessThanCurrentLIPos:BOOL;
	TargetRIPosLessThanCurrentRIPos:BOOL;
	TargetLOPosLessThanCurrentLOPos:BOOL;
	TargetROPosLessThanCurrentROPos:BOOL;
	PositiveMoving:BOOL;
	HysteresisMoving:BOOL;
	NoneHysteresisMoving:BOOL;
	(*Spectroscopy scanning Mode*)
	IsSSMotionMode:BOOL;
	RegularMotionMode:BOOL;
	SSMotionMode:BOOL;
	SS_StepSize:LREAL:=0.001;
	SS_StepNumber:INT:=10;
	SS_StepVelocity:LREAL:=1;
	SS_Move:BOOL;
	SS_Stop:BOOL;
	SS_MoveState:DINT;
	SS_StopState:DINT;
	SS_currentStep:DINT:=0;
	SS_StepSystemTime_Begin:ARRAY[0..100] OF ULINT;
	SS_StepSystemTime_End:ARRAY[0..100] OF ULINT;
	SS_StepCountTime:ARRAY[0..100] OF ULINT;
	SS_TimeCountBegin:BOOL;
	m: INT;
	SS_TON: TON;
	StepEachTime:TIME;
	StepEachTime_ms:INT:=1000;//ms
	SS_OTSTRUCT :OTSTRUCT ;
	SS_StartPositionDisplay:LREAL;
	RTRG_SS_StartPositionDisplay:R_TRIG;
	SS_InitStartPositionDone:BOOL;
	//
	min_SS_StepSize	: LREAL:=0;
	max_SS_StepSize	: LREAL:=200;
	inRange_SS_StepSize	: BOOL;
	//
	min_SS_StepNumber	: INT:=1;
	max_SS_StepNumber	: INT:=1000;
	inRange_SS_StepNumber	: BOOL;
	//
	min_SS_StepVelocity:LREAL:=0;
	max_SS_StepVelocity:LREAL:=1;
	inRange_SS_StepVelocity:BOOL;
	//
	min_StepEachTime_ms:INT:=100;
	max_StepEachTime_ms:INT:=10000;
	inRange_StepEachTime_ms:BOOL;
	l: INT;
	Threshold_UserTopPos_PLC: LREAL;
	Threshold_UserTopVelo_PLC: LREAL;
	Threshold_UserBottomPos_PLC: LREAL;
	Threshold_UserBottomVelo_PLC: LREAL;
	Threshold_UserTBLeftPos_PLC: LREAL;
	Threshold_UserTBLeftVelo_PLC: LREAL;
	Threshold_UserTBRightPos_PLC: LREAL;
	Threshold_UserTBRightVelo_PLC: LREAL;
	Threshold_UserInPos_PLC: LREAL;
	Threshold_UserInVelo_PLC: LREAL;
	Threshold_UserOutPos_PLC: LREAL;
	Threshold_UserOutVelo_PLC: LREAL;
	Threshold_UserIOLeftPos_PLC: LREAL;
	Threshold_UserIOLeftVelo_PLC: LREAL;
	Threshold_UserIORightPos_PLC: LREAL;
	Threshold_UserIORightVelo_PLC: LREAL;
	testa: BOOL;
	testb: BOOL;
	Threshold_GapChangeFlag: LREAL:=0.001;
	Threshold_TaperChangeFlag: LREAL:=0.005;
	TaperAndGapSafetyfactor: LREAL:=1;
	TaperAndGapSafetyScale:LREAL:=0.42;//IAU=0.41,IVU=0.32,CPMU=0.33,IAMW=0.42

		//Global Chain protection-MPS
	Global_ChainProtection_MPS_StorageRingReady:BOOL;
	Global_ChainProtection_MPS_On: BOOL;
	Global_ChainProtection_MPS_MaxGapValue: LREAL;
	Global_ChainProtection_MPS_MoveVelocity: LREAL;
	Global_ChainProtection_MPS_Done: BOOL;
	//Global_ChainProtection_Error: BOOL;
	//Global_ChainProtection_ErrorID: INT;
	//Global_ChainProtection_ErrorDescription: STRING;
	Global_ChainProtection_MPS_ManualOperation:BOOL:=TRUE;
	Global_ChainProtection_MPS_FTRIG:F_TRIG;
	Global_ChainProtection_MPS_FTRIG_Manul:F_TRIG;
	Global_ChainProtection_MPS_TON:TON;
	Global_ChainProtection_MPS_Triggered:BOOL;
	Global_ChainProtection_MPS_In:BOOL;
	Global_ChainProtection_MPS_In1 AT%I* :BOOL;//下降沿表示触发,EL1008
	Global_ChainProtection_MPS_In2 AT%I* :BOOL;
	Global_ChainProtection_MPS_State:DINT;
	Global_ChainProtection_MPS_Out1 AT%Q* :BOOL;//上升沿标识到达最大间隙，连锁保护成功,EL2624
	Global_ChainProtection_MPS_Out2 AT%Q* :BOOL;
	Global_ChainProtection_MPS_TON_Stop2Move:TON;
	Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode:TON;
	Global_ChainProtection_MPS_TON_Power2Move:TON;
	//Global Chain protection-EPS
	Global_ChainProtection_EPS_BeamLineReady:BOOL;
	Global_ChainProtection_EPS_On: BOOL;
	Global_ChainProtection_EPS_MaxGapValue: LREAL;
	Global_ChainProtection_EPS_MoveVelocity: LREAL;
	Global_ChainProtection_EPS_Done: BOOL;
	//Global_ChainProtection_Error: BOOL;
	//Global_ChainProtection_ErrorID: INT;
	//Global_ChainProtection_ErrorDescription: STRING;
	Global_ChainProtection_EPS_ManualOperation:BOOL:=TRUE;
	Global_ChainProtection_EPS_FTRIG:F_TRIG;
	Global_ChainProtection_EPS_FTRIG_Manul:F_TRIG;
	Global_ChainProtection_EPS_TON:TON;
	Global_ChainProtection_EPS_Triggered:BOOL;
	Global_ChainProtection_EPS_In:BOOL;
	Global_ChainProtection_EPS_In1 AT%I* :BOOL;//下降沿表示触发,EL1124
	Global_ChainProtection_EPS_In2 AT%I* :BOOL;
	Global_ChainProtection_EPS_State:DINT;
	Global_ChainProtection_EPS_Out1 AT%Q* :BOOL;//上升沿标识到达最大间隙，连锁保护成功,EL2124
	Global_ChainProtection_EPS_Out2 AT%Q* :BOOL;
	Global_ChainProtection_EPS_TON_Stop2Move:TON;
	Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode:TON;
	Global_ChainProtection_EPS_TON_Power2Move:TON;
	//
	Threshold_motorsTargetPosCalculate: LREAL;
	//
	LeftTopLinPositionNewTemp: LREAL;
	RightTopLinPositionNewTemp: LREAL;
	LeftBottomLinPositionNewTemp: LREAL;
	RightBottomLinPositionNewTemp: LREAL;
	LeftInLinPositionNewTemp: LREAL;
	RightInLinPositionNewTemp: LREAL;
	LeftOutLinPositionNewTemp: LREAL;
	RightOutLinPositionNewTemp: LREAL;
	//OneKeyToMaxGap
	btn_OneKeyToMaxGap:BOOL;
	OneKeyToMaxGap_RTRIG:R_TRIG;
	OneKeyToMaxGap_TON:TON;
	OneKeyToMaxGap_Triggered:BOOL;
	OneKeyToMaxGap_State:DINT;
	OneKeyToMaxGap_TON_Stop2Move:TON;
	OneKeyToMaxGap_TON_Stop2Move_InTaperMode:TON;
	OneKeyToMaxGap_TON_Power2Move:TON;
	OneKeyToMaxGap_Done:BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT PositionBiasDone THEN
	RETURN;
END_IF
IF NOT loadParametersDone THEN
	RETURN;
END_IF
(*btn_Power On/Off*)
IF btn_Power AND NOT st_Power THEN
	btn_PowerOn:=TRUE;
	btn_Power:=FALSE;
END_IF
IF btn_Power AND st_Power THEN
	btn_PowerOff:=TRUE;
	btn_Power:=FALSE;
END_IF
IF btn_PowerOn THEN
	A_PowerOn();
END_IF
IF btn_PowerOff THEN
	A_PowerOff();
END_IF

(*监控四轴位置速度等*)
A_MonitoringAllAxis();

(*补偿数据处理*)
A_InitCompensationData();

(*常规磁间隙开合*)
IF RegularMotionMode AND NOT SSMotionMode THEN
	A_RegularMotion();
END_IF

(*
(*Spectroscopy scanning Mode*)
IF IsSSMotionMode THEN
	SSMotionMode:=TRUE;
	RegularMotionMode:=FALSE;
ELSE
	SSMotionMode:=FALSE;
	RegularMotionMode:=TRUE;
END_IF
IF	SSMotionMode AND NOT RegularMotionMode THEN
	A_SpectroscopyScanningMotion();
END_IF
*)
(*A_CheckMotorsPos*)
A_CheckMotorsPos();

(*GlobalChainProtection*)
A_GlobalChainProtection_MPS();
A_GlobalChainProtection_EPS();
(*A_OneKeyToMaxGap*)
A_OneKeyToMaxGap();
]]></ST>
    </Implementation>
    <Action Name="A_CheckMotorsPos" Id="{f3cd81f2-82fa-493f-8c36-20c483307c7d}">
      <Implementation>
        <ST><![CDATA[//
//目标位置速度超出阈值判断
//
//gap posiion
IF UserGapPositionNew<min_UserGapPositionNew OR UserGapPositionNew>max_UserGapPositionNew THEN
	inRange_UserGapPositionNew:=FALSE;
END_IF
IF UserGapPositionNew>=min_UserGapPositionNew AND UserGapPositionNew<=max_UserGapPositionNew THEN
	inRange_UserGapPositionNew:=TRUE;
END_IF
//gap velocity
IF UserGapVelocityNew<min_UserGapVelocityNew OR UserGapVelocityNew>max_UserGapVelocityNew THEN
	inRange_UserGapVelocityNew:=FALSE;
END_IF
IF UserGapVelocityNew>=min_UserGapVelocityNew AND UserGapVelocityNew<=max_UserGapVelocityNew THEN
	inRange_UserGapVelocityNew:=TRUE;
END_IF
//taper position
IF UserTaperPositionNew<min_UserTaperPositionNew OR UserTaperPositionNew>max_UserTaperPositionNew THEN
	inRange_UserTaperPositionNew:=FALSE;
END_IF
IF UserTaperPositionNew>=min_UserTaperPositionNew AND UserTaperPositionNew<=max_UserTaperPositionNew THEN
	inRange_UserTaperPositionNew:=TRUE;
END_IF
//taper velocity
IF UserTaperVelocityNew<min_UserTaperVelocityNew OR UserTaperVelocityNew>max_UserTaperVelocityNew THEN
	inRange_UserTaperVelocityNew:=FALSE;
END_IF
IF UserTaperVelocityNew>=min_UserTaperVelocityNew AND UserTaperVelocityNew<=max_UserTaperVelocityNew THEN
	inRange_UserTaperVelocityNew:=TRUE;
END_IF
//SS Mode
IF SS_StepSize<min_SS_StepSize OR SS_StepSize>max_SS_StepSize THEN
	inRange_SS_StepSize:=FALSE;
END_IF
IF SS_StepSize>=min_SS_StepSize AND SS_StepSize<=max_SS_StepSize THEN
	inRange_SS_StepSize:=TRUE;
END_IF
IF SS_StepNumber<min_SS_StepNumber OR SS_StepNumber>max_SS_StepNumber THEN
	inRange_SS_StepNumber:=FALSE;
END_IF
IF SS_StepNumber>=min_SS_StepNumber AND SS_StepNumber<=max_SS_StepNumber THEN
	inRange_SS_StepNumber:=TRUE;
END_IF
IF SS_StepVelocity<min_SS_StepVelocity OR SS_StepVelocity>max_SS_StepVelocity THEN
	inRange_SS_StepVelocity:=FALSE;
END_IF
IF SS_StepVelocity>=min_SS_StepVelocity AND SS_StepVelocity<=max_SS_StepVelocity THEN
	inRange_SS_StepVelocity:=TRUE;
END_IF
IF StepEachTime_ms<min_StepEachTime_ms OR StepEachTime_ms>max_StepEachTime_ms THEN
	inRange_StepEachTime_ms:=FALSE;
END_IF
IF StepEachTime_ms>=min_StepEachTime_ms AND StepEachTime_ms<=max_StepEachTime_ms THEN
	inRange_StepEachTime_ms:=TRUE;
END_IF


//
//输入速度和位置保护
//
IF btn_UserGapMove  AND NOT SSMotionMode AND RegularMotionMode THEN
	IF NOT inRange_UserGapPositionNew THEN
		btn_UserGapStop:=TRUE;
		btn_UserGapMove:=FALSE;
		Error:=TRUE;
		ErrorId:=801;
		ErrorDescription:='target Gap position out of range,please check';
		RETURN;
	ELSE
		//btn_UserGapStop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';	
	END_IF
	IF NOT inRange_UserGapVelocityNew THEN
		btn_UserGapStop:=TRUE;
		btn_UserGapMove:=FALSE;
		Error:=TRUE;
		ErrorId:=802;
		ErrorDescription:='target Gap velocity out of range,please check';
		RETURN;
	ELSE
		//btn_UserGapStop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';
	END_IF
	IF NOT inRange_UserTaperPositionNew THEN
		btn_UserGapStop:=TRUE;
		btn_UserGapMove:=FALSE;
		Error:=TRUE;
		ErrorId:=803;
		ErrorDescription:='target Taper Position out of range,please check';
		RETURN;
	ELSE
		//btn_UserGapStop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';
	END_IF
	IF NOT inRange_UserTaperVelocityNew THEN
		btn_UserGapStop:=TRUE;
		btn_UserGapMove:=FALSE;
		Error:=TRUE;
		ErrorId:=804;
		ErrorDescription:='target Taper velocity out of range,please check';
		RETURN;
	ELSE
		//btn_UserGapStop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';
	END_IF
END_IF

//
//运动过程中，监控目标位置速度
//
IF moveStatusAnyAxis THEN
	IF NOT inRange_UserGapPositionNew THEN
		btn_UserGapStop:=TRUE;
		Error:=TRUE;
		ErrorId:=805;
		ErrorDescription:='target Gap position out of range in moving process!';
		FB_PlcEmergencyStop();
	END_IF
	IF NOT inRange_UserGapVelocityNew THEN
		btn_UserGapStop:=TRUE;
		Error:=TRUE;
		ErrorId:=806;
		ErrorDescription:='target Gap velocity out of range in moving process!';
		FB_PlcEmergencyStop();
	END_IF
	IF NOT inRange_UserTaperPositionNew THEN
		btn_UserGapStop:=TRUE;
		Error:=TRUE;
		ErrorId:=807;
		ErrorDescription:='target Taper Position out of range in moving process!';
		FB_PlcEmergencyStop();
	END_IF
	IF NOT inRange_UserTaperVelocityNew THEN
		btn_UserGapStop:=TRUE;
		Error:=TRUE;
		ErrorId:=808;
		ErrorDescription:='target Taper velocity out of range in moving process!';
		FB_PlcEmergencyStop();
	END_IF
END_IF
//
//运动过程中，监控每一个轴的目标位置，目标位置若超出阈值，Emergency
//
IF moveStatusAnyAxis THEN
	IF NOT TaperOrNot THEN
		IF LeftTopLinPositionNew<min_UserGapPositionNew/2 OR LeftTopLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=809;
			ErrorDescription:='target LeftTop position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF RightTopLinPositionNew<min_UserGapPositionNew/2 OR RightTopLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=810;
			ErrorDescription:='target RightTop velocity out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF LeftBottomLinPositionNew<min_UserGapPositionNew/2 OR LeftBottomLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=812;
			ErrorDescription:='target LeftBottom Position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF RightBottomLinPositionNew<min_UserGapPositionNew/2 OR RightBottomLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=813;
			ErrorDescription:='target RightBottom Position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF LeftInLinPositionNew<min_UserGapPositionNew/2 OR LeftInLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=809;
			ErrorDescription:='target LeftIn position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF RightInLinPositionNew<min_UserGapPositionNew/2 OR RightInLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=810;
			ErrorDescription:='target RightIn velocity out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF LeftOutLinPositionNew<min_UserGapPositionNew/2 OR LeftOutLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=812;
			ErrorDescription:='target LeftOut Position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
		IF RightOutLinPositionNew<min_UserGapPositionNew/2 OR RightOutLinPositionNew>max_UserGapPositionNew/2 THEN
			btn_UserGapStop:=TRUE;
			Error:=TRUE;
			ErrorId:=813;
			ErrorDescription:='target RightOut Position out of range in moving process!';
			FB_PlcEmergencyStop();
		END_IF
	ELSE//Taper状态的保护
		;//Taper状态下，不用监控四轴位置，只需要监控目标Taper位置。在上面已经保护
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_GlobalChainProtection_EPS" Id="{06b22d18-fd3c-40de-ae42-96c81b461f09}">
      <Implementation>
        <ST><![CDATA[//硬线输入定义
Global_ChainProtection_EPS_In:=Global_ChainProtection_EPS_In1 AND Global_ChainProtection_EPS_In2;
//硬线输出定义
Global_ChainProtection_EPS_Out1:=Global_ChainProtection_EPS_Done;
Global_ChainProtection_EPS_Out2:=Global_ChainProtection_EPS_Done;
//总开关
IF NOT Global_ChainProtection_EPS_On THEN
	RETURN;
END_IF
//判断插入件状态，是否就位
//IF NOT IDControlReady THEN
//	Global_ChainProtection_EPS_Done:=FALSE;
//	Error:= TRUE;
//	ErrorID:= 1501;
//	ErrorDescription:='ID NOT READY!';
//	RETURN;
//END_IF
//判断储存环是否给出就位信号，暂时由参数表给出TRUE，最终将由IOC接受PV
IF 	NOT Global_ChainProtection_EPS_BeamLineReady THEN
	Global_ChainProtection_EPS_Done:=FALSE;
	Error:= TRUE;
	ErrorID:= 1503;
	ErrorDescription:='Global_ChainProtection_EPS_BeamLineReady NOT Ready';
	RETURN;
END_IF
//
//全局连锁保护程序开始
//
//0.检测到下降沿，触发
//1.判断电机是否在开启状态,没有就打开电源
//2.判断是否在Moving状态,若有就Stop
//3.将磁间隙打开到至最大阈值
//4.到位后给出反馈，且安全PLC触发
Global_ChainProtection_EPS_FTRIG(CLK:=Global_ChainProtection_EPS_In);
IF Global_ChainProtection_EPS_FTRIG.Q THEN
	Global_ChainProtection_EPS_Triggered:=TRUE;
END_IF
Global_ChainProtection_EPS_FTRIG_Manul(CLK:=Global_ChainProtection_EPS_ManualOperation);
IF Global_ChainProtection_EPS_FTRIG_Manul.Q THEN
	Global_ChainProtection_EPS_Triggered:=TRUE;
END_IF
IF Global_ChainProtection_EPS_Triggered THEN
	CASE Global_ChainProtection_EPS_State OF
		0://1.判断电机是否在开启状态,没有就打开电源
			IF st_Power=1 THEN
				Global_ChainProtection_EPS_State:=1;
			ELSE
				btn_PowerOn:=TRUE;
				IF btn_PowerOn THEN
					A_PowerOn();
				END_IF
			END_IF
		1://1.判断是否在谱学扫描模式，如果是，则切换回正常运动模式
			IF IsSSMotionMode THEN
				SS_Stop:=TRUE;
				IsSSMotionMode:=FALSE;
			END_IF
			Global_ChainProtection_EPS_State:=2;
		2://判断是否在taper，如果在taper,则判断是否在运动，如果是，则停止运动,0.5sh后，转入下一步
			IF TaperOrNot THEN
				IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
					btn_UserGapStop:=TRUE;
				ELSE
					Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode(PT:=T#0.5S);
					Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode.IN:=TRUE;
					IF Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode.Q THEN
						TaperOrNot:=FALSE;//关闭taper模式
						Global_ChainProtection_EPS_State:=3;
					END_IF
				END_IF
			ELSE
				Global_ChainProtection_EPS_State:=3;
			END_IF
		3://3.判断是否在Moving状态,若有就Stop.Taper模式已处理完，此处开始走正常GAP开合逻辑
			IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
				btn_UserGapStop:=TRUE;
			ELSE
				Global_ChainProtection_EPS_TON_Stop2Move(PT:=T#0.5S);
				Global_ChainProtection_EPS_TON_Stop2Move.IN:=TRUE;
				IF Global_ChainProtection_EPS_TON_Stop2Move.Q THEN
					Global_ChainProtection_EPS_State:=4;
				END_IF
			END_IF
		4://当前磁间隙如何和最大磁间隙差别不大，不超过0.1，则直接保护
			IF ABS(UserGapPositionDisplay-Global_ChainProtection_EPS_MaxGapValue)<=0.1 THEN
				Global_ChainProtection_EPS_Done:=TRUE;
				Plc_EmergencyStop:=FALSE;	
				Error:=TRUE;
				ErrorID:=1506;
				ErrorDescription:='EPS Triggered,but ABS(UserGapPositionDisplay-Global_ChainProtection_EPS_MaxGapValue)<=0.1 ';	
			ELSE
				Global_ChainProtection_EPS_State:=5;
			END_IF
		5://5.将磁间隙打开到至最大阈值
			Global_ChainProtection_EPS_TON(PT:=INT_TO_TIME(LREAL_TO_INT(Global_ChainProtection_EPS_MaxGapValue/Global_ChainProtection_EPS_MoveVelocity+30))*1000);
			Global_ChainProtection_EPS_TON.IN:=TRUE;
			Global_ChainProtection_EPS_TON_Power2Move(PT:=T#0.1S);
			Global_ChainProtection_EPS_TON_Power2Move.IN:=TRUE;
			UserGapPositionNew:=Global_ChainProtection_EPS_MaxGapValue;
			UserGapVelocityNew:=Global_ChainProtection_EPS_MoveVelocity;
			btn_UserGapMove:=TRUE;
			IF Global_ChainProtection_EPS_TON_Power2Move.Q THEN
				IF FB_MOVE.BCGapDone THEN
					Global_ChainProtection_EPS_State:=88;
				END_IF
			END_IF
			IF Global_ChainProtection_EPS_TON.Q THEN//如果150s后，还没有运动到指定gap，则报错
				Global_ChainProtection_EPS_State:=-100;
			END_IF
		88://6.到位后给出反馈，且安全PLC触发
			Global_ChainProtection_EPS_Done:=TRUE;
			Plc_EmergencyStop:=FALSE;	
			Error:=TRUE;
			ErrorID:=1504;
			ErrorDescription:='Global_ChainProtection_EPS Triggered ';	
		-100:
			Global_ChainProtection_EPS_Done:=FALSE;
			Error:=TRUE;
			ErrorID:=1505;
			ErrorDescription:='NOT MOVING TO MAXGAP';
	END_CASE
END_IF

(*
//硬线输入定义
Global_ChainProtection_EPS_In:=Global_ChainProtection_EPS_In1 AND Global_ChainProtection_EPS_In2;
//硬线输出定义
Global_ChainProtection_EPS_Out1:=Global_ChainProtection_EPS_Done;
Global_ChainProtection_EPS_Out2:=Global_ChainProtection_EPS_Done;
//总开关
IF NOT Global_ChainProtection_EPS_On THEN
	RETURN;
END_IF
//判断插入件状态，是否就位
//IF NOT IDControlReady THEN
//	Global_ChainProtection_EPS_Done:=FALSE;
//	Error:= TRUE;
//	ErrorID:= 1501;
//	ErrorDescription:='ID NOT READY!';
//	RETURN;
//END_IF
//判断储存环是否给出就位信号，暂时由参数表给出TRUE，最终将由IOC接受PV
IF 	NOT Global_ChainProtection_EPS_BeamLineReady THEN
	Global_ChainProtection_EPS_Done:=FALSE;
	Error:= TRUE;
	ErrorID:= 1503;
	ErrorDescription:='Global_ChainProtection_EPS_BeamLineReady NOT Ready';
	RETURN;
END_IF
//
//全局连锁保护程序开始
//
//0.检测到下降沿，触发
//1.判断电机是否在开启状态,没有就打开电源
//2.判断是否在Moving状态,若有就Stop
//3.将磁间隙打开到至最大阈值
//4.到位后给出反馈，且安全PLC触发
Global_ChainProtection_EPS_FTRIG(CLK:=Global_ChainProtection_EPS_In);
IF Global_ChainProtection_EPS_FTRIG.Q THEN
	Global_ChainProtection_EPS_Triggered:=TRUE;
END_IF
Global_ChainProtection_EPS_FTRIG_Manul(CLK:=Global_ChainProtection_EPS_ManualOperation);
IF Global_ChainProtection_EPS_FTRIG_Manul.Q THEN
	Global_ChainProtection_EPS_Triggered:=TRUE;
END_IF
IF Global_ChainProtection_EPS_Triggered THEN
	CASE Global_ChainProtection_EPS_State OF
		0://1.判断电机是否在开启状态,没有就打开电源
			IF st_Power=1 THEN
				Global_ChainProtection_EPS_State:=1;
			ELSE
				btn_PowerOn:=TRUE;
				IF btn_PowerOn THEN
					A_PowerOn();
				END_IF
			END_IF
		1://1.判断是否在谱学扫描模式，如果是，则切换回正常运动模式
			IF IsSSMotionMode THEN
				SS_Stop:=TRUE;
				IsSSMotionMode:=FALSE;
			END_IF
			Global_ChainProtection_EPS_State:=2;
		2://判断是否在taper，如果在taper,则判断是否在运动，如果是，则停止运动,0.5sh后，转入下一步
			IF TaperOrNot THEN
				IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
					btn_UserGapStop:=TRUE;
				ELSE
					Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode(PT:=T#0.5S);
					Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode.IN:=TRUE;
					IF Global_ChainProtection_EPS_TON_Stop2Move_InTaperMode.Q THEN
						TaperOrNot:=FALSE;//关闭taper模式
						Global_ChainProtection_EPS_State:=3;
					END_IF
				END_IF
			ELSE
				Global_ChainProtection_EPS_State:=3;
			END_IF
		3://3.判断是否在Moving状态,若有就Stop.Taper模式已处理完，此处开始走正常GAP开合逻辑
			IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
				OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
				btn_UserGapStop:=TRUE;
			ELSE
				Global_ChainProtection_EPS_TON_Stop2Move(PT:=T#0.5S);
				Global_ChainProtection_EPS_TON_Stop2Move.IN:=TRUE;
				IF Global_ChainProtection_EPS_TON_Stop2Move.Q THEN
					Global_ChainProtection_EPS_State:=4;
				END_IF
			END_IF
		4://4.将磁间隙打开到至最大阈值
			Global_ChainProtection_EPS_TON(PT:=INT_TO_TIME(LREAL_TO_INT(Global_ChainProtection_EPS_MaxGapValue/Global_ChainProtection_EPS_MoveVelocity+30))*1000);
			Global_ChainProtection_EPS_TON.IN:=TRUE;
			Global_ChainProtection_EPS_TON_Power2Move(PT:=T#0.1S);
			Global_ChainProtection_EPS_TON_Power2Move.IN:=TRUE;
			UserGapPositionNew:=Global_ChainProtection_EPS_MaxGapValue;
			UserGapVelocityNew:=Global_ChainProtection_EPS_MoveVelocity;
			btn_UserGapMove:=TRUE;
			IF Global_ChainProtection_EPS_TON_Power2Move.Q THEN
				IF FB_MOVE.BCGapDone THEN
					Global_ChainProtection_EPS_State:=88;
				END_IF
			END_IF
			IF Global_ChainProtection_EPS_TON.Q THEN//如果150s后，还没有运动到指定gap，则报错
				Global_ChainProtection_EPS_State:=-100;
			END_IF
		88://4.到位后给出反馈，且安全PLC触发
			Global_ChainProtection_EPS_Done:=TRUE;
			Plc_EmergencyStop:=FALSE;	
			Error:=TRUE;
			ErrorID:=1504;
			ErrorDescription:='Global_ChainProtection_EPS Triggered ';	
		-100:
			Global_ChainProtection_EPS_Done:=FALSE;
			Error:=TRUE;
			ErrorID:=1505;
			ErrorDescription:='NOT MOVING TO MAXGAP';
	END_CASE
END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_GlobalChainProtection_MPS" Id="{214f7982-b3a1-46e2-bee6-e29b232f3cd2}">
      <Implementation>
        <ST><![CDATA[//硬线输入定义
Global_ChainProtection_MPS_In:=Global_ChainProtection_MPS_In1 AND Global_ChainProtection_MPS_In2;
//硬线输出定义
Global_ChainProtection_MPS_Out1:=Global_ChainProtection_MPS_Done;
Global_ChainProtection_MPS_Out2:=Global_ChainProtection_MPS_Done;
//总开关
IF NOT Global_ChainProtection_MPS_On THEN
	RETURN;
END_IF
//判断插入件状态，是否就位
//IF NOT IDControlReady THEN
//	Global_ChainProtection_MPS_Done:=FALSE;
//	Error:= TRUE;
//	ErrorID:= 1401;
//	ErrorDescription:='ID NOT READY!';
//	RETURN;
//END_IF
//判断储存环是否给出就位信号，暂时由参数表给出TRUE，最终将由IOC接受PV
IF 	NOT Global_ChainProtection_MPS_StorageRingReady THEN
	Global_ChainProtection_MPS_Done:=FALSE;
	Error:= TRUE;
	ErrorID:= 1403;
	ErrorDescription:='StorageRingChainProtection NOT Ready';
	RETURN;
END_IF
//
//全局连锁保护程序开始
//
//0.检测到下降沿，触发
//1.判断电机是否在开启状态,没有就打开电源
//2.判断是否在Moving状态,若有就Stop
//3.将磁间隙打开到至最大阈值
//4.到位后给出反馈，且安全PLC触发
Global_ChainProtection_MPS_FTRIG(CLK:=Global_ChainProtection_MPS_In);
IF Global_ChainProtection_MPS_FTRIG.Q THEN
	Global_ChainProtection_MPS_Triggered:=TRUE;
END_IF
Global_ChainProtection_MPS_FTRIG_Manul(CLK:=Global_ChainProtection_MPS_ManualOperation);
IF Global_ChainProtection_MPS_FTRIG_Manul.Q THEN
	Global_ChainProtection_MPS_Triggered:=TRUE;
END_IF
IF Global_ChainProtection_MPS_Triggered THEN
	CASE Global_ChainProtection_MPS_State OF
		0://1.判断电机是否在开启状态,没有就打开电源
			IF st_Power=1 THEN
				Global_ChainProtection_MPS_State:=1;
			ELSE
				btn_PowerOn:=TRUE;
				IF btn_PowerOn THEN
					A_PowerOn();
				END_IF
			END_IF
		1://1.判断是否在谱学扫描模式，如果是，则切换回正常运动模式
			IF IsSSMotionMode THEN
				SS_Stop:=TRUE;
				IsSSMotionMode:=FALSE;
			END_IF
			Global_ChainProtection_MPS_State:=2;
		2://判断是否在taper，如果在taper,则判断是否在运动，如果是，则停止运动,0.5sh后，转入下一步
			IF TaperOrNot THEN
				IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
					btn_UserGapStop:=TRUE;
				ELSE
					Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode(PT:=T#0.5S);
					Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode.IN:=TRUE;
					IF Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode.Q THEN
						TaperOrNot:=FALSE;//关闭taper模式
						Global_ChainProtection_MPS_State:=3;
					END_IF
				END_IF
			ELSE
				Global_ChainProtection_MPS_State:=3;
			END_IF
		3://3.判断是否在Moving状态,若有就Stop.Taper模式已处理完，此处开始走正常GAP开合逻辑
			IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
					btn_UserGapStop:=TRUE;
				ELSE
				Global_ChainProtection_MPS_TON_Stop2Move(PT:=T#0.5S);
				Global_ChainProtection_MPS_TON_Stop2Move.IN:=TRUE;
				IF Global_ChainProtection_MPS_TON_Stop2Move.Q THEN
					Global_ChainProtection_MPS_State:=4;
				END_IF
			END_IF
		4://当前磁间隙如何和最大磁间隙差别不大，不超过0.1，则直接保护
			IF ABS(UserGapPositionDisplay-Global_ChainProtection_MPS_MaxGapValue)<=0.1 THEN
				Global_ChainProtection_MPS_Done:=TRUE;
				Plc_EmergencyStop:=FALSE;	
				Error:=TRUE;
				ErrorID:=1406;
				ErrorDescription:='MPS Triggered,but ABS(UserGapPositionDisplay-Global_ChainProtection_MPS_MaxGapValue)<=0.1 ';	
			ELSE
				Global_ChainProtection_MPS_State:=5;
			END_IF
		5://5.将磁间隙打开到至最大阈值
			Global_ChainProtection_MPS_TON(PT:=INT_TO_TIME(LREAL_TO_INT(Global_ChainProtection_MPS_MaxGapValue/Global_ChainProtection_MPS_MoveVelocity+30))*1000);
			Global_ChainProtection_MPS_TON.IN:=TRUE;
			Global_ChainProtection_MPS_TON_Power2Move(PT:=T#0.1S);
			Global_ChainProtection_MPS_TON_Power2Move.IN:=TRUE;
			UserGapPositionNew:=Global_ChainProtection_MPS_MaxGapValue;
			UserGapVelocityNew:=Global_ChainProtection_MPS_MoveVelocity;
			btn_UserGapMove:=TRUE;
			IF Global_ChainProtection_MPS_TON_Power2Move.Q THEN
				IF FB_MOVE.BCGapDone THEN
					Global_ChainProtection_MPS_State:=88;
				END_IF
			END_IF
			IF Global_ChainProtection_MPS_TON.Q THEN//如果150s后，还没有运动到指定gap，则报错
				Global_ChainProtection_MPS_State:=-100;
			END_IF
		88://6.到位后给出反馈，且安全PLC触发
			Global_ChainProtection_MPS_Done:=TRUE;
			Plc_EmergencyStop:=FALSE;	
			Error:=TRUE;
			ErrorID:=1404;
			ErrorDescription:='Global_ChainProtection_MPS Triggered ';	
		-100:
			Global_ChainProtection_MPS_Done:=FALSE;
			Error:=TRUE;
			ErrorID:=1405;
			ErrorDescription:='NOT MOVING TO MAXGAP';
	END_CASE
END_IF


(*
//硬线输入定义
Global_ChainProtection_MPS_In:=Global_ChainProtection_MPS_In1 AND Global_ChainProtection_MPS_In2;
//硬线输出定义
Global_ChainProtection_MPS_Out1:=Global_ChainProtection_MPS_Done;
Global_ChainProtection_MPS_Out2:=Global_ChainProtection_MPS_Done;
//总开关
IF NOT Global_ChainProtection_MPS_On THEN
	RETURN;
END_IF
//判断插入件状态，是否就位
//IF NOT IDControlReady THEN
//	Global_ChainProtection_MPS_Done:=FALSE;
//	Error:= TRUE;
//	ErrorID:= 1401;
//	ErrorDescription:='ID NOT READY!';
//	RETURN;
//END_IF
//判断储存环是否给出就位信号，暂时由参数表给出TRUE，最终将由IOC接受PV
IF 	NOT Global_ChainProtection_MPS_StorageRingReady THEN
	Global_ChainProtection_MPS_Done:=FALSE;
	Error:= TRUE;
	ErrorID:= 1403;
	ErrorDescription:='StorageRingChainProtection NOT Ready';
	RETURN;
END_IF
//
//全局连锁保护程序开始
//
//0.检测到下降沿，触发
//1.判断电机是否在开启状态,没有就打开电源
//2.判断是否在Moving状态,若有就Stop
//3.将磁间隙打开到至最大阈值
//4.到位后给出反馈，且安全PLC触发
Global_ChainProtection_MPS_FTRIG(CLK:=Global_ChainProtection_MPS_In);
IF Global_ChainProtection_MPS_FTRIG.Q THEN
	Global_ChainProtection_MPS_Triggered:=TRUE;
END_IF
Global_ChainProtection_MPS_FTRIG_Manul(CLK:=Global_ChainProtection_MPS_ManualOperation);
IF Global_ChainProtection_MPS_FTRIG_Manul.Q THEN
	Global_ChainProtection_MPS_Triggered:=TRUE;
END_IF
IF Global_ChainProtection_MPS_Triggered THEN
	CASE Global_ChainProtection_MPS_State OF
		0://1.判断电机是否在开启状态,没有就打开电源
			IF st_Power=1 THEN
				Global_ChainProtection_MPS_State:=1;
			ELSE
				btn_PowerOn:=TRUE;
				IF btn_PowerOn THEN
					A_PowerOn();
				END_IF
			END_IF
		1://1.判断是否在谱学扫描模式，如果是，则切换回正常运动模式
			IF IsSSMotionMode THEN
				SS_Stop:=TRUE;
				IsSSMotionMode:=FALSE;
			END_IF
			Global_ChainProtection_MPS_State:=2;
		2://判断是否在taper，如果在taper,则判断是否在运动，如果是，则停止运动,0.5sh后，转入下一步
			IF TaperOrNot THEN
				IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
					btn_UserGapStop:=TRUE;
				ELSE
					Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode(PT:=T#0.5S);
					Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode.IN:=TRUE;
					IF Global_ChainProtection_MPS_TON_Stop2Move_InTaperMode.Q THEN
						TaperOrNot:=FALSE;//关闭taper模式
						Global_ChainProtection_MPS_State:=3;
					END_IF
				END_IF
			ELSE
				Global_ChainProtection_MPS_State:=3;
			END_IF
		3://3.判断是否在Moving状态,若有就Stop.Taper模式已处理完，此处开始走正常GAP开合逻辑
			IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom 
					OR moveStatusLeftIn OR moveStatusRightIn OR moveStatusLeftOut OR moveStatusRightOut THEN
				btn_UserGapStop:=TRUE;
			ELSE
				Global_ChainProtection_MPS_TON_Stop2Move(PT:=T#0.5S);
				Global_ChainProtection_MPS_TON_Stop2Move.IN:=TRUE;
				IF Global_ChainProtection_MPS_TON_Stop2Move.Q THEN
					Global_ChainProtection_MPS_State:=4;
				END_IF
			END_IF
		4://4.将磁间隙打开到至最大阈值
			Global_ChainProtection_MPS_TON(PT:=INT_TO_TIME(LREAL_TO_INT(Global_ChainProtection_MPS_MaxGapValue/Global_ChainProtection_MPS_MoveVelocity+30))*1000);
			Global_ChainProtection_MPS_TON.IN:=TRUE;
			Global_ChainProtection_MPS_TON_Power2Move(PT:=T#0.1S);
			Global_ChainProtection_MPS_TON_Power2Move.IN:=TRUE;
			UserGapPositionNew:=Global_ChainProtection_MPS_MaxGapValue;
			UserGapVelocityNew:=Global_ChainProtection_MPS_MoveVelocity;
			btn_UserGapMove:=TRUE;
			IF Global_ChainProtection_MPS_TON_Power2Move.Q THEN
				IF FB_MOVE.BCGapDone THEN
					Global_ChainProtection_MPS_State:=88;
				END_IF
			END_IF
			IF Global_ChainProtection_MPS_TON.Q THEN//如果150s后，还没有运动到指定gap，则报错
				Global_ChainProtection_MPS_State:=-100;
			END_IF
		88://4.到位后给出反馈，且安全PLC触发
			Global_ChainProtection_MPS_Done:=TRUE;
			Plc_EmergencyStop:=FALSE;	
			Error:=TRUE;
			ErrorID:=1404;
			ErrorDescription:='Global_ChainProtection_MPS Triggered ';	
		-100:
			Global_ChainProtection_MPS_Done:=FALSE;
			Error:=TRUE;
			ErrorID:=1405;
			ErrorDescription:='NOT MOVING TO MAXGAP';
	END_CASE
END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_InitCompensationData" Id="{1e6a9c39-c8a5-4c48-b57c-71effe5e3747}">
      <Implementation>
        <ST><![CDATA[(*补偿开始*)
IF USE_SingleAxis_Compensation THEN
	//
	//1.目标位置解算
	//
	(*通过补偿表解算四轴目标位置*)
	//左轴位置由Gap定，右轴位置由右gap定。右gap值=左gap+taper。taper模式和非taper模式一样，非taper模式只是一种特例存在
	//左轴目标位置解算
	IF NOT TaperOrNot THEN
		UserTaperPositionNew:=0;
		//UserTaperPositionDisplay:=0;
	END_IF
	UserRightGapPositionNew:=UserGapPositionNew+UserTaperPositionNew;
	//左轴目标位置解算
	FOR	i:= 1 TO 17 DO
			IF UserGapPositionNew/2<M_Compensation[i+1].Encoder AND UserGapPositionNew/2>=M_Compensation[i].Encoder THEN
				IF i<>18 THEN
					LeftTopLinPositionNew:=(((UserGapPositionNew/2-M_Compensation[i].Encoder)*(M_Compensation[i+1].LeftTop-M_Compensation[i].LeftTop))
							/(M_Compensation[i+1].Encoder-M_Compensation[i].Encoder))+M_Compensation[i].LeftTop;
					LeftBottomLinPositionNew:=(((UserGapPositionNew/2-M_Compensation[i].Encoder)*(M_Compensation[i+1].LeftBottom-M_Compensation[i].LeftBottom))
							/(M_Compensation[i+1].Encoder-M_Compensation[i].Encoder))+M_Compensation[i].LeftBottom;
					LeftInLinPositionNew:=(((UserGapPositionNew/2-M_Compensation[i].Encoder)*(M_Compensation[i+1].LeftIn-M_Compensation[i].LeftIn))
							/(M_Compensation[i+1].Encoder-M_Compensation[i].Encoder))+M_Compensation[i].LeftIn;
					LeftOutLinPositionNew:=(((UserGapPositionNew/2-M_Compensation[i].Encoder)*(M_Compensation[i+1].LeftOut-M_Compensation[i].LeftOut))
							/(M_Compensation[i+1].Encoder-M_Compensation[i].Encoder))+M_Compensation[i].LeftOut;
					M_CompensationNumber:=i;
					InitCompensationDatasDone:=TRUE;
				ELSIF i=18 AND UserGapPositionNew/2=M_Compensation[i].Encoder THEN		(*Gap=14µÄÌØÊâÇé¿ö*)
					(**)
					LeftTopLinPositionNew:=M_Compensation[i].LeftTop;
					LeftBottomLinPositionNew:=M_Compensation[i].LeftBottom;
					LeftInLinPositionNew:=M_Compensation[i].LeftIn;
					LeftOutLinPositionNew:=M_Compensation[i].LeftOut;
					M_CompensationNumber:=i;
					InitCompensationDatasDone:=TRUE;
				ELSE
					LeftTopLinPositionNew:=UserGapPositionNew/2;
					LeftBottomLinPositionNew:=UserGapPositionNew/2;
					LeftInLinPositionNew:=UserGapPositionNew/2;
					LeftOutLinPositionNew:=UserGapPositionNew/2;
					M_CompensationNumber:=i;
					InitCompensationDatasDone:=TRUE;
				END_IF
			END_IF
	END_FOR
	//右轴目标位置解算
	FOR	j:= 1 TO 17 DO
		IF UserRightGapPositionNew/2<M_Compensation[j+1].Encoder AND UserRightGapPositionNew/2>=M_Compensation[j].Encoder THEN
			IF j<>18 THEN
				RightTopLinPositionNew:=(((UserRightGapPositionNew/2-M_Compensation[j].Encoder)*(M_Compensation[j+1].RightTop-M_Compensation[j].RightTop))
						/(M_Compensation[j+1].Encoder-M_Compensation[j].Encoder))+M_Compensation[j].RightTop;
				RightBottomLinPositionNew:=(((UserRightGapPositionNew/2-M_Compensation[j].Encoder)*(M_Compensation[j+1].RightBottom-M_Compensation[j].RightBottom))
						/(M_Compensation[j+1].Encoder-M_Compensation[j].Encoder))+M_Compensation[j].RightBottom;
				RightInLinPositionNew:=(((UserRightGapPositionNew/2-M_Compensation[j].Encoder)*(M_Compensation[j+1].RightIn-M_Compensation[j].RightIn))
						/(M_Compensation[j+1].Encoder-M_Compensation[j].Encoder))+M_Compensation[j].RightIn;
				RightOutLinPositionNew:=(((UserRightGapPositionNew/2-M_Compensation[j].Encoder)*(M_Compensation[j+1].RightOut-M_Compensation[j].RightOut))
						/(M_Compensation[j+1].Encoder-M_Compensation[j].Encoder))+M_Compensation[j].RightOut;
				M_CompensationNumber:=j;
				InitCompensationDatasDone:=TRUE;
			ELSIF j=18 AND UserRightGapPositionNew/2=M_Compensation[i].Encoder THEN		(*Gap=14µÄÌØÊâÇé¿ö*)
				(**)
				RightTopLinPositionNew:=M_Compensation[i].RightTop;
				RightBottomLinPositionNew:=M_Compensation[i].RightBottom;
				RightInLinPositionNew:=M_Compensation[i].RightIn;
				RightOutLinPositionNew:=M_Compensation[i].RightOut;
				M_CompensationNumber:=j;
				InitCompensationDatasDone:=TRUE;
			ELSE
				RightTopLinPositionNew:=UserGapPositionNew/2;
				RightBottomLinPositionNew:=UserGapPositionNew/2;
				RightInLinPositionNew:=UserGapPositionNew/2;
				RightOutLinPositionNew:=UserGapPositionNew/2;
				M_CompensationNumber:=j;
				InitCompensationDatasDone:=TRUE;
			END_IF
		END_IF
	END_FOR
	//
	//2.不论taper还是非taper模式，左轴gap都有左轴发推算，右轴gap由右轴反推算。taper为右gap-左gap
	//
	//左轴显示位置反结算
	FOR k:= 1 TO 17 DO
			IF Pos_LeftTopLin<M_Compensation[k+1].LeftTop AND Pos_LeftTopLin>=M_Compensation[k].LeftTop THEN
				UserGapPositionDisplay_FromLeftTop:=2*(((Pos_LeftTopLin-M_Compensation[k].LeftTop)*(M_Compensation[k+1].Encoder-M_Compensation[k].Encoder))
											/(M_Compensation[k+1].LeftTop-M_Compensation[k].LeftTop)+M_Compensation[k].Encoder);
				UserGapPositionDisplay_FromLeftBottom:=2*(((Pos_LeftBottomLin-M_Compensation[k].LeftBottom)*(M_Compensation[k+1].Encoder-M_Compensation[k].Encoder))
											/(M_Compensation[k+1].LeftBottom-M_Compensation[k].LeftBottom)+M_Compensation[k].Encoder);									
				UserGapPositionDisplay_FromLeftIn:=2*(((Pos_LeftInLin-M_Compensation[k].LeftIn)*(M_Compensation[k+1].Encoder-M_Compensation[k].Encoder))
											/(M_Compensation[k+1].LeftIn-M_Compensation[k].LeftIn)+M_Compensation[k].Encoder);
				UserGapPositionDisplay_FromLeftOut:=2*(((Pos_LeftOutLin-M_Compensation[k].LeftOut)*(M_Compensation[k+1].Encoder-M_Compensation[k].Encoder))
											/(M_Compensation[k+1].LeftOut-M_Compensation[k].LeftOut)+M_Compensation[k].Encoder);
				UserGapPositionDisplay:=DINT_TO_LREAL(LREAL_TO_DINT(((UserGapPositionDisplay_FromLeftTop+UserGapPositionDisplay_FromLeftBottom
																	+UserGapPositionDisplay_FromLeftIn+UserGapPositionDisplay_FromLeftOut)/4)*100000))/100000;
			END_IF
	END_FOR
	//右轴显示位置反结算
	FOR m:= 1 TO 17 DO
			IF Pos_RightTopLin<M_Compensation[m+1].RightTop AND Pos_RightTopLin>=M_Compensation[m].RightTop THEN
				UserRightGapPositionDisplay_FromRightTop:=2*(((Pos_RightTopLin-M_Compensation[m].RightTop)*(M_Compensation[m+1].Encoder-M_Compensation[m].Encoder))
											/(M_Compensation[m+1].RightTop-M_Compensation[m].RightTop)+M_Compensation[m].Encoder);
				UserRightGapPositionDisplay_FromRightBottom:=2*(((Pos_RightBottomLin-M_Compensation[m].RightBottom)*(M_Compensation[m+1].Encoder-M_Compensation[m].Encoder))
											/(M_Compensation[m+1].RightBottom-M_Compensation[m].RightBottom)+M_Compensation[m].Encoder);									
				UserRightGapPositionDisplay_FromRightIn:=2*(((Pos_RightInLin-M_Compensation[m].RightIn)*(M_Compensation[m+1].Encoder-M_Compensation[m].Encoder))
											/(M_Compensation[m+1].RightIn-M_Compensation[m].RightIn)+M_Compensation[m].Encoder);
				UserRightGapPositionDisplay_FromRightOut:=2*(((Pos_RightOutLin-M_Compensation[m].RightOut)*(M_Compensation[m+1].Encoder-M_Compensation[m].Encoder))
											/(M_Compensation[m+1].RightOut-M_Compensation[m].RightOut)+M_Compensation[m].Encoder);
				UserRightGapPositionDisplay:=DINT_TO_LREAL(LREAL_TO_DINT(((UserRightGapPositionDisplay_FromRightTop+UserRightGapPositionDisplay_FromRightBottom
												+UserRightGapPositionDisplay_FromRightIn+UserRightGapPositionDisplay_FromRightOut)/4)*100000))/100000;
			END_IF
	END_FOR
		IF TaperOrNot OR (Global_ChainProtection_MPS_Triggered OR Global_ChainProtection_EPS_Triggered)  THEN//安全联锁触发时，需要UserTaperPositionDisplay作为A_MonitoringAllAxis的保护
			UserTaperPositionDisplay:=DINT_TO_LREAL(LREAL_TO_DINT((UserRightGapPositionDisplay-UserGapPositionDisplay)*100000))/100000;
		UserTaperVelocityDisplay:=DINT_TO_LREAL(LREAL_TO_DINT((Velo_RightTopLin+Velo_RightBottomLin+Velo_RightInLin+Velo_RightOutLin)/4*100000))/100000;
	END_IF

	(*速度可以不用解算，直接用即可*)
	LeftTopLinVelocityDisplay:=Velo_LeftTopLin;
	RightTopLinVelocityDisplay:=Velo_RightTopLin;
	LeftBottomLinVelocityDisplay:=Velo_LeftBottomLin;
	RightBottomLinVelocityDisplay:=Velo_RightBottomLin;
	LeftInLinVelocityDisplay:=Velo_LeftInLin;
	RightInLinVelocityDisplay:=Velo_RightInLin;
	LeftOutLinVelocityDisplay:=Velo_LeftOutLin;
	RightOutLinVelocityDisplay:=Velo_RightOutLin;
	//Gap velocity
	UserGapVelocityDisplay:=DINT_TO_LREAL(LREAL_TO_DINT(((LeftTopLinVelocityDisplay+RightTopLinVelocityDisplay+
	LeftBottomLinVelocityDisplay+RightBottomLinVelocityDisplay+
	LeftInLinVelocityDisplay+RightInLinVelocityDisplay+
	LeftOutLinVelocityDisplay+RightOutLinVelocityDisplay)/4)*100000))/100000;

	(*解算单轴位置后，核验并做保护*)
	IF ABS(LeftTopLinPositionNew-UserGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1601;
		Error:=TRUE;
		ErrorDescription:='LeftTop Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	//注意右轴解算以UserRightGapPositionNew为基准，考虑到taper
	IF ABS(RightTopLinPositionNew-UserRightGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1602;
		Error:=TRUE;
		ErrorDescription:='RightTop Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	IF ABS(LeftBottomLinPositionNew-UserGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1603;
		Error:=TRUE;
		ErrorDescription:='LeftBottom Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	//注意右轴解算以UserRightGapPositionNew为基准，考虑到taper
	IF ABS(RightBottomLinPositionNew-UserRightGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1604;
		Error:=TRUE;
		ErrorDescription:='RightBottom Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	IF ABS(LeftInLinPositionNew-UserGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1605;
		Error:=TRUE;
		ErrorDescription:='LeftIn Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	IF ABS(RightInLinPositionNew-UserRightGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1606;
		Error:=TRUE;
		ErrorDescription:='RightIn Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	IF ABS(LeftOutLinPositionNew-UserGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1607;
		Error:=TRUE;
		ErrorDescription:='LeftOut Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
	IF ABS(RightOutLinPositionNew-UserRightGapPositionNew/2)>Threshold_motorsTargetPosCalculate THEN
		ErrorID:=1608;
		Error:=TRUE;
		ErrorDescription:='RightOut Threshold_motorsTargetPosCalculate';
		FB_PlcEmergencyStop();
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_MonitoringAllAxis" Id="{ca11d2cd-2857-4b76-bcfc-746a563d8a76}">
      <Implementation>
        <ST><![CDATA[(****************************************************************
NAME:			A_MonitoringAllAxis
DATA:			2018.1.9
VERSION:		1.0.0
DESCRIPTION:	
				Ã¿´ÎÑ­»·¾ùÖ´ÐÐÖáÎ»ÖÃºÍÖáÔË¶¯µÄ¼ì²é
				2.4Öá¹âÕ¤³ßÎ»ÖÃ¡¢ËÙ¶È¶Ô±È¼ì²é
HISTORY:
				2017.1.9		NEW

***************************************************************)

(*************************************************************************************2.4Öá¹âÕ¤³ßÎ»ÖÃ¡¢ËÙ¶È¶Ô±È¼ì²é**********************************************************************)
IF  st_Power<>0 THEN
CASE moni_State OF
(*Top Î»ÖÃºÍËÙ¶È±È¶Ô*)
0:
		//实际(*Position*)
		(*Top*)
		Diff_UserTopPos_actual:=ABS(Pos_leftTopLin-Pos_RightTopLin);
		(*Bottom*)
		Diff_UserBottomPos_actual:=ABS(Pos_LeftBottomLin-Pos_RightBottomLin);
		(*TBLeft*)
		Diff_UserTBLeftPos_actual:=ABS(Pos_LeftTopLin-Pos_LeftBottomLin);
		(*TBRight*)
		Diff_UserTBRightPos_actual:=ABS(Pos_RightTopLin-Pos_RightBottomLin);
		(*In*)
		Diff_UserInPos_actual:=ABS(Pos_leftInLin-Pos_RightInLin);
		(*Out*)
		Diff_UserOutPos_actual:=ABS(Pos_LeftOutLin-Pos_RightOutLin);
		(*IOLeft*)
		Diff_UserIOLeftPos_actual:=ABS(Pos_LeftInLin-Pos_LeftOutLin);
		(*IORight*)
		Diff_UserIORightPos_actual:=ABS(Pos_RightInLin-Pos_RightOutLin);
		(*Velocity*)
		(*Top*)
		Diff_UserTopVelo_actual:=ABS(Velo_leftTopLin-Velo_RightTopLin);
		(*Bottom*)
		Diff_UserBottomVelo_actual:=ABS(Velo_LeftBottomLin-Velo_RightBottomLin);
		(*TBLeft*)
		Diff_UserTBLeftVelo_actual:=ABS(Velo_LeftTopLin-Velo_LeftBottomLin);
		(*TBRight*)
		Diff_UserTBRightVelo_actual:=ABS(Velo_RightTopLin-Velo_RightBottomLin);
		(*In*)
		Diff_UserInVelo_actual:=ABS(Velo_leftInLin-Velo_RightInLin);
		(*Out*)
		Diff_UserOutVelo_actual:=ABS(Velo_LeftOutLin-Velo_RightOutLin);
		(*IOLeft*)
		Diff_UserIOLeftVelo_actual:=ABS(Velo_LeftInLin-Velo_LeftOutLin);
		(*IORight*)
		Diff_UserIORightVelo_actual:=ABS(Velo_RightInLin-Velo_RightOutLin);
		//阈值
		Threshold_UserTopPos_PLC:=Threshold_UserTopPos+UserTaperPositionDisplay;//Top位置误差=gap运动细微误差+目标taper位置
		Threshold_UserTopVelo_PLC:=Threshold_UserTopVelo+ABS(UserGapVelocityDisplay);//Top速度误差=gap运动细微误差+gap目标速度。因为可能出现一个轴运动完了，另一个轴还在运动的情况
		Threshold_UserBottomPos_PLC:=Threshold_UserBottomPos+UserTaperPositionDisplay;//Bottom同上
		Threshold_UserBottomVelo_PLC:=Threshold_UserBottomVelo+ABS(UserGapVelocityDisplay);//Bottom同上
		Threshold_UserTBLeftPos_PLC:=Threshold_UserTBLeftPos+UserTaperPositionDisplay;
		Threshold_UserTBLeftVelo_PLC:=Threshold_UserTBLeftVelo+ABS(UserGapVelocityDisplay);
		Threshold_UserTBRightPos_PLC:=Threshold_UserTBRightPos+UserTaperPositionDisplay;
		Threshold_UserTBRightVelo_PLC:=Threshold_UserTBRightVelo+ABS(UserGapVelocityDisplay);
		//
		
		Threshold_UserInPos_PLC:=Threshold_UserInPos+UserTaperPositionDisplay;//Top位置误差=gap运动细微误差+目标taper位置
		Threshold_UserInVelo_PLC:=Threshold_UserInVelo+ABS(UserGapVelocityDisplay);//Top速度误差=gap运动细微误差+gap目标速度。因为可能出现一个轴运动完了，另一个轴还在运动的情况
		Threshold_UserOutPos_PLC:=Threshold_UserOutPos+UserTaperPositionDisplay;//Bottom同上
		Threshold_UserOutVelo_PLC:=Threshold_UserOutVelo+ABS(UserGapVelocityDisplay);//Bottom同上
		Threshold_UserIOLeftPos_PLC:=Threshold_UserIOLeftPos+UserTaperPositionDisplay;
		Threshold_UserIOLeftVelo_PLC:=Threshold_UserIOLeftVelo+ABS(UserGapVelocityDisplay);
		Threshold_UserIORightPos_PLC:=Threshold_UserIORightPos+UserTaperPositionDisplay;
		Threshold_UserIORightVelo_PLC:=Threshold_UserIORightVelo+ABS(UserGapVelocityDisplay);
		//比较
		IF Diff_UserTopPos_actual >Threshold_UserTopPos_PLC THEN
				Error:=TRUE;
				ErrorID:=601;
				ErrorDescription:='Diff_UserTopPos_actual >Threshold_UserTopPos_PLC';
				moni_State:=-100;
		ELSIF Diff_UserTopVelo_actual>Threshold_UserTopVelo_PLC  THEN
				Error:=TRUE;
				ErrorID:=602;
				ErrorDescription:='Diff_UserTopVelo_actual>Threshold_UserTopVelo_PLC';
				moni_State:=-100;
		(*Bottom Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserBottomPos_actual>Threshold_UserBottomPos_PLC THEN
				Error:=TRUE;
				ErrorID:=603;
				ErrorDescription:='Diff_UserBottomPos_actual>Threshold_UserBottomPos_PLC';
				moni_State:=-100;
		ELSIF Diff_UserBottomVelo_actual>Threshold_UserBottomVelo_PLC  THEN
				Error:=TRUE;
				ErrorID:=604;
				ErrorDescription:='Diff_UserBottomVelo_actual>Threshold_UserBottomVelo_PLC';
				moni_State:=-100;
		(*Left Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserTBLeftPos_actual>Threshold_UserTBLeftPos_PLC  THEN
				Error:=TRUE;
				ErrorID:=605;
				ErrorDescription:='Diff_UserTBLeftPos_actual>Threshold_UserTBLeftPos_PLC';
				moni_State:=-100;
		ELSIF  Diff_UserTBLeftVelo_actual>Threshold_UserTBLeftVelo_PLC THEN
				Error:=TRUE;
				ErrorID:=606;
				ErrorDescription:='Diff_UserTBLeftVelo_actual>Threshold_UserTBLeftVelo_PLC';
				moni_State:=-100;
		(*Right Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserTBRightPos_actual>Threshold_UserTBRightPos_PLC  THEN
				Error:=TRUE;
				ErrorID:=607;
				ErrorDescription:='Diff_UserTBRightPos_actual>Threshold_UserTBRightPos_PLC';
				moni_State:=-100;
		ELSIF  Diff_UserTBRightVelo_actual>Threshold_UserTBRightVelo_PLC THEN
				Error:=TRUE;
				ErrorID:=608;
				ErrorDescription:='Diff_UserTBRightVelo_actual>Threshold_UserTBRightVelo_PLC';
				moni_State:=-100;
		END_IF
		//
		IF Diff_UserInPos_actual >Threshold_UserInPos_PLC THEN
				Error:=TRUE;
				ErrorID:=609;
				ErrorDescription:='Diff_UserInPos_actual >Threshold_UserInPos_PLC';
				moni_State:=-100;
		ELSIF Diff_UserInVelo_actual>Threshold_UserInVelo_PLC  THEN
				Error:=TRUE;
				ErrorID:=610;
				ErrorDescription:='Diff_UserInVelo_actual>Threshold_UserInVelo_PLC';
				moni_State:=-100;
		(*Out Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserOutPos_actual>Threshold_UserOutPos_PLC THEN
				Error:=TRUE;
				ErrorID:=611;
				ErrorDescription:='Diff_UserOutPos_actual>Threshold_UserOutPos_PLC';
				moni_State:=-100;
		ELSIF Diff_UserOutVelo_actual>Threshold_UserOutVelo_PLC  THEN
				Error:=TRUE;
				ErrorID:=612;
				ErrorDescription:='Diff_UserOutVelo_actual>Threshold_UserOutVelo_PLC';
				moni_State:=-100;
		(*Left Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserIOLeftPos_actual>Threshold_UserIOLeftPos_PLC  THEN
				Error:=TRUE;
				ErrorID:=613;
				ErrorDescription:='Diff_UserIOLeftPos_actual>Threshold_UserIOLeftPos_PLC';
				moni_State:=-100;
		ELSIF  Diff_UserIOLeftVelo_actual>Threshold_UserIOLeftVelo_PLC THEN
				Error:=TRUE;
				ErrorID:=614;
				ErrorDescription:='Diff_UserIOLeftVelo_actual>Threshold_UserIOLeftVelo_PLC';
				moni_State:=-100;
		(*Right Î»ÖÃºÍËÙ¶È±È¶Ô*)
		ELSIF Diff_UserIORightPos_actual>Threshold_UserIORightPos_PLC  THEN
				Error:=TRUE;
				ErrorID:=615;
				ErrorDescription:='Diff_UserIORightPos_actual>Threshold_UserIORightPos_PLC';
				moni_State:=-100;
		ELSIF  Diff_UserIORightVelo_actual>Threshold_UserIORightVelo_PLC THEN
				Error:=TRUE;
				ErrorID:=616;
				ErrorDescription:='Diff_UserIORightVelo_actual>Threshold_UserIORightVelo_PLC';
				moni_State:=-100;
		END_IF
-100:
		btn_UserGapStop:=TRUE;
		FB_PlcEmergencyStop();
		Error:=TRUE;
		LED_Error:=TRUE;
END_CASE
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_OneKeyToMaxGap" Id="{ba9dc3e9-1e8e-4d76-8af6-498bfc77c09c}">
      <Implementation>
        <ST><![CDATA[//0.上升沿触发
//1.判断电机是否在开启状态,没有就打开电源
//2.判断是否在Moving状态,若有就Stop
//3.将磁间隙打开到至最大阈值
//4.到位后给出反馈
OneKeyToMaxGap_RTRIG(CLK:=btn_OneKeyToMaxGap);
IF OneKeyToMaxGap_RTRIG.Q THEN
	OneKeyToMaxGap_Triggered:=TRUE;
	OneKeyToMaxGap_Done:=FALSE;
END_IF
IF OneKeyToMaxGap_Triggered THEN
	CASE OneKeyToMaxGap_State OF
		0://1.判断电机是否在开启状态,没有就打开电源
			IF st_Power=1 THEN
				OneKeyToMaxGap_State:=1;
			ELSE
				btn_PowerOn:=TRUE;
				IF btn_PowerOn THEN
					A_PowerOn();
				END_IF
			END_IF
		1://1.判断是否在谱学扫描模式，如果是，则切换回正常运动模式
			IF IsSSMotionMode THEN
				SS_Stop:=TRUE;
				IsSSMotionMode:=FALSE;
			END_IF
			OneKeyToMaxGap_State:=2;
		2://判断是否在taper，如果在taper,则判断是否在运动，如果是，则停止运动,0.5sh后，转入下一步
			IF TaperOrNot THEN
				IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom THEN
					btn_UserGapStop:=TRUE;
				ELSE
					OneKeyToMaxGap_TON_Stop2Move_InTaperMode(PT:=T#0.5S);
					OneKeyToMaxGap_TON_Stop2Move_InTaperMode.IN:=TRUE;
					IF OneKeyToMaxGap_TON_Stop2Move_InTaperMode.Q THEN
						TaperOrNot:=FALSE;//关闭taper模式
						OneKeyToMaxGap_State:=3;
						OneKeyToMaxGap_TON_Stop2Move_InTaperMode.IN:=FALSE;
					END_IF
				END_IF
			ELSE
				OneKeyToMaxGap_State:=3;
			END_IF
		3://3.判断是否在Moving状态,若有就Stop.Taper模式已处理完，此处开始走正常GAP开合逻辑
			IF moveStatusLeftTop OR moveStatusRightTop OR moveStatusLeftBottom OR moveStatusRightBottom THEN
				btn_UserGapStop:=TRUE;
			ELSE
				OneKeyToMaxGap_TON_Stop2Move(PT:=T#0.5S);
				OneKeyToMaxGap_TON_Stop2Move.IN:=TRUE;
				IF OneKeyToMaxGap_TON_Stop2Move.Q THEN
					OneKeyToMaxGap_State:=4;
					OneKeyToMaxGap_TON_Stop2Move.IN:=FALSE;
				END_IF
			END_IF
		4://4.将磁间隙打开到至最大阈值
			OneKeyToMaxGap_TON(PT:=INT_TO_TIME(LREAL_TO_INT(max_UserGapPositionNew+30))*1000);
			OneKeyToMaxGap_TON.IN:=TRUE;
			OneKeyToMaxGap_TON_Power2Move(PT:=T#0.1S);
			OneKeyToMaxGap_TON_Power2Move.IN:=TRUE;
			UserGapPositionNew:=max_UserGapPositionNew;
			UserGapVelocityNew:=1;
			btn_UserGapMove:=TRUE;
			IF OneKeyToMaxGap_TON_Power2Move.Q THEN
				OneKeyToMaxGap_TON_Power2Move.IN:=FALSE;
				IF FB_MOVE.BCGapDone THEN
					OneKeyToMaxGap_State:=88;
				END_IF
			END_IF
			IF OneKeyToMaxGap_TON.Q THEN//如果150s后，还没有运动到指定gap，则报错
				OneKeyToMaxGap_TON.IN:=FALSE;
				OneKeyToMaxGap_State:=-100;
			END_IF
			IF  btn_UserGapStop THEN
				//
				OneKeyToMaxGap_State:=0;
				OneKeyToMaxGap_Triggered:=FALSE;
				btn_OneKeyToMaxGap:=FALSE;
				OneKeyToMaxGap_Triggered:=FALSE;
				OneKeyToMaxGap_State:=0;
			END_IF
		88://6.到位后给出反馈
			OneKeyToMaxGap_Done:=TRUE;	
			Error:=FALSE;
			ErrorID:=0;
			ErrorDescription:='';
			btn_OneKeyToMaxGap:=FALSE;
			OneKeyToMaxGap_Triggered:=FALSE;
			OneKeyToMaxGap_State:=0;
				
		-100:
			OneKeyToMaxGap_Done:=FALSE;
			Error:=TRUE;
			ErrorID:=1705;
			ErrorDescription:='OneKeyToMaxGap Fail';
			btn_OneKeyToMaxGap:=FALSE;
			OneKeyToMaxGap_Triggered:=FALSE;
			OneKeyToMaxGap_State:=0;
	END_CASE
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PowerOff" Id="{e3ff8ae4-6e0c-4bb4-9a62-00e47841163f}">
      <Implementation>
        <ST><![CDATA[CASE d_state OF
		0:(*PowerOff*)
			FB_Power(Off:=TRUE);
				d_state:=1;
		1:
			IF NOT FB_power.OffStatus THEN
				d_state:=1;
			ELSE
				d_state:=88;
			END_IF
		88:(*ResetAllState*)
			btn_PowerOn:=FALSE;
			btn_UserGapMove:=FALSE;
			btn_UserGapStop:=FALSE;
			fb_ton1.IN:=FALSE;
			fb_ton2.IN:=FALSE;
			fb_ton3.IN:=FALSE;
			State:=0;
			Busy:=FALSE;
			InitPowerDone:=FALSE;
			InitCompensationDatasDone:=FALSE;
			Error:=FALSE;
			ErrorID:=0;
			m_state:=0;
			n_state:=0;
			s_state:=0;
			btn_PowerOff:=FALSE;
			d_state:=0;
			Led_Run:=FALSE;
			Led_Error:=FALSE;
			moni_State:=0;
			i:=0;
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PowerOn" Id="{cacab3c1-f169-458e-acb8-60acf8e4d140}">
      <Implementation>
        <ST><![CDATA[(****************************************************************
NAME:			A_PowerOn
DATA:			2018.1.9
VERSION:		1.0.0
DESCRIPTION:	
				ÉÏµãÃüÁîºó£¬Ë³ÐòÖ´ÐÐ£º
				1.FB_PowerOn
				·µ»ØÖ´ÐÐÊÇ·ñ³É¹¦
HISTORY:
				2019.1.9		NEW

***************************************************************)
fb_ton3(PT:=t#0.5s);
CASE State OF
	0:	(*FB_Power_On*)
		FB_Power(On:=TRUE);
		fb_ton3.IN:=TRUE;
		State:=1;
	1:	(*wait*)
		FB_power();
		IF NOT FB_power.OnStatus THEN		(*FB_Power_OnÃ»ÓÐÖ´ÐÐÍê£¬wait£¬³¬Ê±FB Error*)
			IF NOT fb_ton3.Q THEN
				State:=1;
			ELSE
				ErrorID:=1;
				State:=99;
			END_IF
		ELSE
			State:=88;
		END_IF
	88:	(*All Done*)
		btn_PowerOn:=FALSE;
		State:=0;
		Error:=FALSE;
		ErrorID:=0;
		Busy:=FALSE;
		InitPowerDone:=TRUE;
		FB_power.On:=FALSE;
		fb_ton3.IN:=FALSE;
		LED_Error:=FALSE;
	99:
		Error:=TRUE;
		//ErrorID:=701;
		//ErrorDescription:='power on error';		
		btn_PowerOn:=FALSE;
		State:=99;
		Busy:=FALSE;
		InitPowerDone:=FALSE;
		fb_ton3.IN:=FALSE;
		LED_Error:=TRUE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_RegularMotion" Id="{79d2706f-89ad-4612-adf2-c80c9fc85b18}">
      <Implementation>
        <ST><![CDATA[(*如果该ID没有taper需求，则TaperFunctionSolidOn=FALSE，则判定taperOrNot为false*)
IF NOT TaperFunctionSolidOn THEN
	TaperOrNot:=FALSE;
END_IF
(*若GAP将有变化，首先检测TAPER是否超出阈值，若超出，则报错，提示必须先将TAPER回归到0，才可以改变GAP*)
IF NOT (Global_ChainProtection_MPS_Triggered OR Global_ChainProtection_EPS_Triggered) THEN//在触发联锁保护后，taper保护关闭
	IF ABS(UserGapPositionNew-UserGapPositionDisplay)>Threshold_GapChangeFlag AND btn_UserGapMove THEN
		IF UserTaperPositionDisplay>Threshold_TaperChangeFlag THEN
			btn_UserGapStop:=TRUE;
			btn_UserGapMove:=FALSE;
			Error:=TRUE;
			ErrorId:=809;
			ErrorDescription:='Please Move Taper to zero first before move gap';
			RETURN;
		END_IF
	END_IF
END_IF
(*Taper和gap连锁限制性保护。比如11mm时候如果taper，入口端gap变小，会有压真空盒的问题。设置保护*)
IF NOT (Global_ChainProtection_MPS_Triggered OR Global_ChainProtection_EPS_Triggered)  THEN//在触发联锁保护后，taper保护关闭
	IF UserGapPositionNew-TaperAndGapSafetyfactor*TaperAndGapSafetyScale*UserTaperPositionNew<=min_UserGapPositionNew AND btn_UserGapMove THEN
			btn_UserGapStop:=TRUE;
			btn_UserGapMove:=FALSE;
			Error:=TRUE;
			ErrorId:=810;
			ErrorDescription:='Target taper is too big at current Gap';
			RETURN;
	END_IF
END_IF
(*分别比较四轴目标位置与当前位置的差，如果目标位置比当前位置低，则需要运动到更低-回程差一半；再运动至最终目标位置*)
//只在m=和n=0的时候判断，否则会出现一些BUG，比如往大间隙开时，运动到位后m不能回到0.
IF m_state=0 AND n_state=0 THEN
		TargetPosLessThanCurrentPos:=FALSE;
	IF LeftTopLinPositionNew-Pos_LeftTopLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetLTPosLessThanCurrentLTPos:=TRUE;
	ELSE
			TargetLTPosLessThanCurrentLTPos:=FALSE;
	END_IF
	IF RightTopLinPositionNew-Pos_RightTopLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetRTPosLessThanCurrentRTPos:=TRUE;
	ELSE
			TargetRTPosLessThanCurrentRTPos:=FALSE;
	END_IF
	IF LeftBottomLinPositionNew-Pos_LeftBottomLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetLBPosLessThanCurrentLBPos:=TRUE;
	ELSE
			TargetLBPosLessThanCurrentLBPos:=FALSE;
	END_IF
	IF RightBottomLinPositionNew-Pos_RightBottomLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetRBPosLessThanCurrentRBPos:=TRUE;
	ELSE
			TargetRBPosLessThanCurrentRBPos:=FALSE;
	END_IF
	IF LeftInLinPositionNew-Pos_LeftInLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetLIPosLessThanCurrentLIPos:=TRUE;
	ELSE
			TargetLIPosLessThanCurrentLIPos:=FALSE;
	END_IF
	IF RightInLinPositionNew-Pos_RightInLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetRIPosLessThanCurrentRIPos:=TRUE;
	ELSE
			TargetRIPosLessThanCurrentRIPos:=FALSE;
	END_IF
	IF LeftOutLinPositionNew-Pos_LeftOutLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetLOPosLessThanCurrentLOPos:=TRUE;
	ELSE
			TargetLOPosLessThanCurrentLOPos:=FALSE;
	END_IF
	IF RightOutLinPositionNew-Pos_RightOutLin<-LEDriftErrorThreshold THEN
			TargetPosLessThanCurrentPos:=TRUE;
			TargetROPosLessThanCurrentROPos:=TRUE;
	ELSE
			TargetROPosLessThanCurrentROPos:=FALSE;
	END_IF
END_IF

(*Move*)
IF InitCompensationDatasDone THEN
		(*四轴目标位置都大于当前位置，直接走到目标位置即可，不需要先走到考虑回城误差的临时位置*)
		IF NOT TargetPosLessThanCurrentPos AND NOT HysteresisMoving THEN
			CASE m_state OF
				0:
					FB_Move.Mode:=5;						//1.gap;2.single;3.taper;4.debug;5.BCGap&UserMode
					FB_Move.CoupleState:=st_Couple;			
					FB_Move.PowerState:=st_Power;						
			
					IF btn_UserGapMove THEN
						IF NOT st_Power THEN
							ErrorID:=1501;
							Error:=TRUE;
							ErrorDescription:='Plz PowerOn Frist';
							LED_Error:=TRUE;
							//btn_UserGapMove:=FALSE;
							RETURN;
						ELSE
							ErrorID:=0;
							Error:=FALSE;
							ErrorDescription:='';
							LED_Error:=FALSE;
							//btn_UserGapMove:=TRUE;
						END_IF
						//目标速度位置赋值
						FB_Move.BCLeftTopPosition:=LeftTopLinPositionNew;
						FB_Move.BCRightTopPosition:=RightTopLinPositionNew;
						FB_Move.BCLeftBottomPosition:=LeftBottomLinPositionNew;
						FB_Move.BCRightBottomPosition:=RightBottomLinPositionNew;
						FB_Move.BCLeftInPosition:=LeftInLinPositionNew;
						FB_Move.BCRightInPosition:=RightInLinPositionNew;
						FB_Move.BCLeftOutPosition:=LeftOutLinPositionNew;
						FB_Move.BCRightOutPosition:=RightOutLinPositionNew;
						IF NOT TaperOrNot THEN
							FB_Move.BCLeftTopVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightTopVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftBottomVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightBottomVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftInVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightInVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftOutVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightOutVelocity:=UserGapVelocityNew/2;
						ELSE
							FB_Move.BCLeftTopVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightTopVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftBottomVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightBottomVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftInVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightInVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftOutVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightOutVelocity:=UserTaperVelocityNew;
						END_IF
							FB_Move.BCGapMove:=TRUE;
							m_state:=1;
							FB_Move();
					END_IF
				1:
					btn_UserGapMove:=FALSE;
					FB_Move();
					IF NOT FB_Move.BCGapDone THEN
						Led_Run:=TRUE;
						m_state:=1;
					ELSE
						m_state:=88;
					END_IF
				88:
					btn_UserGapMove:=FALSE;
					Led_Run:=FALSE;
					m_state:=0;
			END_CASE
		(*四轴有目标位置小于当前位置，先走到临时位置，再走到目标位置*)
		ELSE
			CASE n_state OF
				0:
					FB_Move.Mode:=5;						//1.gap;2.single;3.taper;4.debug;5.BCGap&UserMode;5:userMode_2
					FB_Move.CoupleState:=st_Couple;			
					FB_Move.PowerState:=st_Power;			
					IF btn_UserGapMove THEN	
						IF NOT st_Power THEN
							ErrorID:=1501;
							Error:=TRUE;
							ErrorDescription:='Plz PowerOn Frist';
							LED_Error:=TRUE;
							//btn_UserGapMove:=FALSE;
							RETURN;
						ELSE
							ErrorID:=0;
							Error:=FALSE;
							ErrorDescription:='';
							LED_Error:=FALSE;
							//btn_UserGapMove:=TRUE;
						END_IF						
						//
						IF TargetLTPosLessThanCurrentLTPos THEN			
							FB_Move.BCLeftTopPosition:=LeftTopLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCLeftTopPosition:=LeftTopLinPositionNew;	
						END_IF
						//
						IF TargetRTPosLessThanCurrentRTPos THEN 
							FB_Move.BCRightTopPosition:=RightTopLinPositionNew-HysteresisError/2;
						ELSE					
							FB_Move.BCRightTopPosition:=RightTopLinPositionNew;
						END_IF
						//
						IF TargetLBPosLessThanCurrentLBPos THEN
							FB_Move.BCLeftBottomPosition:=LeftBottomLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCLeftBottomPosition:=LeftBottomLinPositionNew;
						END_IF
						//
						IF TargetRBPosLessThanCurrentRBPos THEN
							FB_Move.BCRightBottomPosition:=RightBottomLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCRightBottomPosition:=RightBottomLinPositionNew;
						END_IF						
						//
						IF TargetLIPosLessThanCurrentLIPos THEN			
							FB_Move.BCLeftInPosition:=LeftInLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCLeftInPosition:=LeftInLinPositionNew;	
						END_IF
						//
						IF TargetRIPosLessThanCurrentRIPos THEN 
							FB_Move.BCRightInPosition:=RightInLinPositionNew-HysteresisError/2;
						ELSE					
							FB_Move.BCRightInPosition:=RightInLinPositionNew;
						END_IF
						//
						IF TargetLOPosLessThanCurrentLOPos THEN
							FB_Move.BCLeftOutPosition:=LeftOutLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCLeftOutPosition:=LeftOutLinPositionNew;
						END_IF
						//
						IF TargetROPosLessThanCurrentROPos THEN
							FB_Move.BCRightOutPosition:=RightOutLinPositionNew-HysteresisError/2;
						ELSE
							FB_Move.BCRightOutPosition:=RightOutLinPositionNew;
						END_IF		
						//	close gap情况下，加入了LeftTopLinPositionNewTemp。//
						//如果在往小间隙运行过程中，改变了目标gap，会在第到达第一次目标位置后，继续向第二
						//次输入的目标运动，而不会回到第一次的目标位置。用temp锁定目标位置
						LeftTopLinPositionNewTemp:=LeftTopLinPositionNew;
						RightTopLinPositionNewTemp:=RightTopLinPositionNew;
						LeftBottomLinPositionNewTemp:=LeftBottomLinPositionNew;
						RightBottomLinPositionNewTemp:=RightBottomLinPositionNew;
						LeftInLinPositionNewTemp:=LeftInLinPositionNew;
						RightInLinPositionNewTemp:=RightInLinPositionNew;
						LeftOutLinPositionNewTemp:=LeftOutLinPositionNew;
						RightOutLinPositionNewTemp:=RightOutLinPositionNew;
			
						//
						IF NOT TaperOrNot THEN
							FB_Move.BCLeftTopVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightTopVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftBottomVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightBottomVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftInVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightInVelocity:=UserGapVelocityNew/2;
							FB_Move.BCLeftOutVelocity:=UserGapVelocityNew/2;
							FB_Move.BCRightOutVelocity:=UserGapVelocityNew/2;
							IF UserGapVelocityNew >1 THEN								  
								ErrorID:=1502;
								Error:=TRUE;
								ErrorDescription:='UserGapVelocityNew must<=1';
								LED_Error:=TRUE;
								btn_UserGapMove:=FALSE;
								RETURN;
							ELSE
								ErrorID:=0;
								Error:=FALSE;
								ErrorDescription:='';
								LED_Error:=FALSE;	
							END_IF									
						ELSE
							FB_Move.BCLeftTopVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightTopVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftBottomVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightBottomVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftInVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightInVelocity:=UserTaperVelocityNew;
							FB_Move.BCLeftOutVelocity:=UserTaperVelocityNew;
							FB_Move.BCRightOutVelocity:=UserTaperVelocityNew;
						END_IF	

						FB_Move.BCGapMove:=TRUE;
						FB_Move();
						HysteresisMoving:=TRUE;		
						n_state:=1;	
					END_IF
				1:
					btn_UserGapMove:=FALSE;
					FB_Move();
					IF NOT FB_Move.BCGapDone THEN			(*还未运动到位置,运动过程中*)
						Led_Run:=TRUE;
						n_state:=1;
					ELSE									
						n_state:=2;							(*转到下一步，运动到最终位置*)
						FB_Move.BCGapMove:=FALSE;
						//Led_Run:=FALSE;
					END_IF
				2:
					FB_Move.BCGapReset:=FALSE;
					FB_Move.Mode:=5;						//1.gap;2.single;3.taper;4.debug;5.BCGap&UserMode
					FB_Move.CoupleState:=st_Couple;			
					FB_Move.PowerState:=st_Power;			
					FB_Move.BCGapMove:=TRUE;
					//直接走到目标位置，已经走到位置的，可以继续下命令，只不过它不在走了而已
					FB_Move.BCLeftTopPosition:=LeftTopLinPositionNewTemp;	
					FB_Move.BCRightTopPosition:=RightTopLinPositionNewTemp;
					FB_Move.BCLeftBottomPosition:=LeftBottomLinPositionNewTemp;
					FB_Move.BCRightBottomPosition:=RightBottomLinPositionNewTemp;
					FB_Move.BCLeftInPosition:=LeftInLinPositionNewTemp;	
					FB_Move.BCRightInPosition:=RightInLinPositionNewTemp;
					FB_Move.BCLeftOutPosition:=LeftOutLinPositionNewTemp;
					FB_Move.BCRightOutPosition:=RightOutLinPositionNewTemp;
					//
					IF NOT TaperOrNot THEN
						FB_Move.BCLeftTopVelocity:=UserGapVelocityNew/2;
						FB_Move.BCRightTopVelocity:=UserGapVelocityNew/2;
						FB_Move.BCLeftBottomVelocity:=UserGapVelocityNew/2;
						FB_Move.BCRightBottomVelocity:=UserGapVelocityNew/2;
						FB_Move.BCLeftInVelocity:=UserGapVelocityNew/2;
						FB_Move.BCRightInVelocity:=UserGapVelocityNew/2;
						FB_Move.BCLeftOutVelocity:=UserGapVelocityNew/2;
						FB_Move.BCRightOutVelocity:=UserGapVelocityNew/2;
					ELSE
						FB_Move.BCLeftTopVelocity:=UserTaperVelocityNew;
						FB_Move.BCRightTopVelocity:=UserTaperVelocityNew;
						FB_Move.BCLeftBottomVelocity:=UserTaperVelocityNew;
						FB_Move.BCRightBottomVelocity:=UserTaperVelocityNew;
						FB_Move.BCLeftInVelocity:=UserTaperVelocityNew;
						FB_Move.BCRightInVelocity:=UserTaperVelocityNew;
						FB_Move.BCLeftOutVelocity:=UserTaperVelocityNew;
						FB_Move.BCRightOutVelocity:=UserTaperVelocityNew;
					END_IF
					FB_Move();							
					n_state:=3;
				3:
					FB_Move();
					IF NOT FB_Move.BCGapDone THEN			(*还未运动到位置,运动过程中*)
						Led_Run:=TRUE;
						n_state:=3;
					ELSE									
						n_state:=88;							(*运动到了最终位置*)
					END_IF
					(*
					IF NOT Unreach_LS_Bottom THEN
						n_state:=88;							(*在运动过程中如果碰到下限位，则也转到下一步，运动到最终位置*)
						FB_Move.BCGapMove_2:=FALSE;
					END_IF
					*)
				88:
					btn_UserGapMove:=FALSE;					
					Led_Run:=FALSE;
					n_state:=0;
					HysteresisMoving:=FALSE;
			END_CASE
		END_IF
	//
	//FB_Move.BCLeftTopPosition等四轴位置监控
	//
END_IF

IF btn_UserGapStop OR btn_Reset THEN
	FB_Move.BCGapReset:=TRUE;
	FB_Move();	
	btn_UserGapMove:=FALSE;	
	m_state:=0;	
	n_state:=0;	
	HysteresisMoving:=FALSE;
	CASE s_state OF
			0:
				FB_Stop.Mode:=5;	
				FB_Stop.CoupleState:=st_Couple;	
				FB_Stop.PowerState:=st_Power;
				FB_Stop.BCGapStop:=TRUE;
				FB_Stop();	
				s_state:=1;
			1:
				FB_Stop();
				IF NOT FB_Stop.BCGapDone THEN
					s_state:=1;
				ELSE
					s_state:=88;
				END_IF
			88:
				btn_UserGapStop:=FALSE;	
				FB_Move.BCGapReset:=FALSE;
				btn_reset:=FALSE;
				s_state:=0;
		END_CASE
END_IF

(*触发限位开关后，相当于点击了Stop按钮*)
FTrig_ReachLS(CLK:=Unreach_LS_Far AND Unreach_LS_Near);
IF FTrig_ReachLS.Q THEN
	btn_UserGapStop:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_SpectroscopyScanningMotion" Id="{6676a965-5ff1-46e4-b651-02d2762b99bc}">
      <Implementation>
        <ST><![CDATA[(*
(*输入保护*)
IF SS_Move AND SSMotionMode AND NOT RegularMotionMode THEN
	IF NOT inRange_SS_StepSize THEN
		SS_Stop:=TRUE;
		SS_Move:=FALSE;
		Error:=TRUE;
		ErrorId:=805;
		ErrorDescription:='target StepSize out of range,please check';
		RETURN;
	ELSE
		SS_Stop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';	
	END_IF
	//
	IF NOT inRange_SS_StepNumber THEN
		SS_Stop:=TRUE;
		SS_Move:=FALSE;
		Error:=TRUE;
		ErrorId:=806;
		ErrorDescription:='target StepNumber out of range,please check';
		RETURN;
	ELSE
		SS_Stop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';	
	END_IF
	IF NOT inRange_SS_StepVelocity THEN
		SS_Stop:=TRUE;
		SS_Move:=FALSE;
		Error:=TRUE;
		ErrorId:=807;
		ErrorDescription:='target StepVelocity out of range,please check';
		RETURN;
	ELSE
		SS_Stop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';	
	END_IF
	IF NOT inRange_StepEachTime_ms THEN
		SS_Stop:=TRUE;
		SS_Move:=FALSE;
		Error:=TRUE;
		ErrorId:=808;
		ErrorDescription:='target StepEachTime_ms out of range,please check';
		RETURN;
	ELSE
		SS_Stop:=FALSE;
		Error:=FALSE;
		ErrorId:=0;
		ErrorDescription:='';	
	END_IF
END_IF
(*单步时长转换*)
StepEachTime:=INT_TO_TIME(StepEachTime_ms);
SS_TON(PT:=StepEachTime);
(*上升沿触发，初始SS位置=当前磁间隙*)
RTRG_SS_StartPositionDisplay(CLK:=SS_Move);
IF RTRG_SS_StartPositionDisplay.Q THEN
	SS_StartPositionDisplay:=UserGapPositionDisplay;
	SS_InitStartPositionDone:=TRUE;
END_IF
(*SS主程序*)
IF InitPowerDone AND InitCompensationDatasDone AND SS_Move AND SS_InitStartPositionDone THEN
	CASE SS_MoveState OF
		0:
				//UserGapPositionNew:=UserGapPositionDisplay+SS_StepSize;
				UserGapPositionNew:=SS_StartPositionDisplay+SS_StepSize*(SS_currentStep+1);
				A_InitCompensationData();
				FB_Move.Mode:=5;						//1.gap;2.single;3.taper;4.debug;5.BCGap&UserMode
				FB_Move.CoupleState:=st_Couple;			
				FB_Move.PowerState:=st_Power;							
				FB_Move.BCLeftTopPosition:=LeftTopLinPositionNew;
				FB_Move.BCLeftTopVelocity:=UserGapVelocityNew/2;
				FB_Move.BCRightTopPosition:=RightTopLinPositionNew;
				FB_Move.BCRightTopVelocity:=UserGapVelocityNew/2;
				FB_Move.BCLeftBottomPosition:=LeftBottomLinPositionNew;
				FB_Move.BCLeftBottomVelocity:=UserGapVelocityNew/2;
				FB_Move.BCRightBottomPosition:=RightBottomLinPositionNew;
				FB_Move.BCRightBottomVelocity:=UserGapVelocityNew/2;		
				FB_Move.BCGapMove:=TRUE;
				FB_Move();
				SS_MoveState:=1;
		1:
				SS_TON.IN:=TRUE;
				FB_Move();
				IF FB_Move.GapMoving AND NOT SS_TimeCountBegin THEN
					SS_StepSystemTime_Begin[SS_currentStep]:=F_GetSysTime();
					SS_TimeCountBegin:=TRUE;
				END_IF
				IF NOT FB_Move.BCGapDone THEN			
					Led_Run:=TRUE;
					SS_MoveState:=1;
				ELSE									
					SS_MoveState:=66;
					SS_StepSystemTime_End[SS_currentStep]:=F_GetSysTime();
					SS_StepCountTime[SS_currentStep]:=SS_StepSystemTime_End[SS_currentStep]-SS_StepSystemTime_Begin[SS_currentStep];
					SS_TimeCountBegin:=FALSE;
				END_IF
		66:
				SS_currentStep:=SS_currentStep+1;			
				Led_Run:=FALSE;
				IF SS_currentStep=SS_StepNumber THEN								
					SS_MoveState:=88;
				END_IF
				IF SS_currentStep<SS_StepNumber THEN
					SS_MoveState:=77;
				END_IF
		77://等待单步时长够
				IF SS_TON.Q THEN
					SS_TON.IN:=FALSE;
					SS_MoveState:=0;
				END_IF
		88:
				SS_TON.IN:=FALSE;
				SS_Move:=FALSE;	
				Led_Run:=FALSE;
				SS_MoveState:=0;
				SS_currentStep:=0;
				SS_InitStartPositionDone:=FALSE;
				//SS_StepSystemTime[SS_StepNumber]:=F_GetSysTime();
	END_CASE
END_IF
(*获取每一步耗时*)
//FOR	m:= 0 TO SS_StepNumber DO
//	SS_StepCountTime[m]:=(SS_StepSystemTime_End[m]-SS_StepSystemTime_Begin[m]);
//END_FOR

(*STOP*)
IF SS_Stop THEN
	FB_Move.BCGapReset:=TRUE;							(*¸øÔË¶¯FB¸øÍ£Ö¹ÐÅºÅ£¬Ê¹FB_Move×´Ì¬»Ö¸´*)
	FB_Move();											(*Æô¶¯FB_Move*)
	SS_Move:=FALSE;								(*btn_GapMove:=FALSE*)
	SS_MoveState:=0;										(*m_state:=0;*)
	CASE SS_StopState OF
			0:
				FB_Stop.Mode:=5;							(*1£ºgapÄ£Ê½£»2£ºµ¥ÁºÄ£Ê½£»3£ºtaperÄ£Ê½£»4£ºDebugÄ£Ê½£»5£ºBCGapÄ£Ê½*)
				FB_Stop.CoupleState:=st_Couple;			(*ñîºÏ×´Ì¬ÊäÈë*)
				FB_Stop.PowerState:=st_Power;				(*µçÔ´×´Ì¬ÊäÈë*)
				FB_Stop.BCGapStop:=TRUE;				(*Execute TRUE*)
				FB_Stop();								(*Æô¶¯FB*)
				SS_StopState:=1;
			1:
				FB_Stop();
				IF NOT FB_Stop.BCGapDone THEN			(*Í£Ö¹Î´Íê³É£¬Ñ­»·*)
					SS_StopState:=1;
				ELSE									(*Í£Ö¹Íê³É£¬ÏÂÒ»²½*)
					SS_StopState:=88;
				END_IF
			88:
				SS_Stop:=FALSE;						(*»Ö¸´×´Ì¬*)
				FB_Move.BCGapReset:=FALSE;				(*ÔËÐÐFB*)
				SS_StopState:=0;
		END_CASE
END_IF

(*触发限位开关后，相当于点击了Stop按钮*)
FTrig_ReachLS(CLK:=Unreach_LS_Far AND Unreach_LS_Near);
IF FTrig_ReachLS.Q THEN
	SS_Stop:=TRUE;
END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="UserMode">
      <LineId Id="767" Count="1" />
      <LineId Id="770" Count="0" />
      <LineId Id="883" Count="1" />
      <LineId Id="882" Count="0" />
      <LineId Id="40" Count="8" />
      <LineId Id="52" Count="1" />
      <LineId Id="51" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="542" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="543" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="544" Count="0" />
      <LineId Id="406" Count="0" />
      <LineId Id="548" Count="0" />
      <LineId Id="530" Count="0" />
      <LineId Id="549" Count="0" />
      <LineId Id="1314" Count="0" />
      <LineId Id="545" Count="0" />
      <LineId Id="445" Count="0" />
      <LineId Id="1149" Count="1" />
      <LineId Id="1152" Count="2" />
      <LineId Id="1156" Count="0" />
      <LineId Id="1155" Count="0" />
      <LineId Id="550" Count="0" />
      <LineId Id="528" Count="0" />
      <LineId Id="551" Count="0" />
      <LineId Id="655" Count="0" />
      <LineId Id="570" Count="0" />
      <LineId Id="656" Count="0" />
      <LineId Id="1691" Count="2" />
      <LineId Id="1690" Count="0" />
      <LineId Id="1910" Count="0" />
      <LineId Id="1491" Count="0" />
      <LineId Id="1011" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_CheckMotorsPos">
      <LineId Id="176" Count="2" />
      <LineId Id="122" Count="53" />
      <LineId Id="121" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="117" Count="1" />
      <LineId Id="33" Count="53" />
      <LineId Id="247" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="119" Count="1" />
      <LineId Id="88" Count="28" />
      <LineId Id="31" Count="0" />
      <LineId Id="28" Count="2" />
      <LineId Id="180" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="181" Count="20" />
      <LineId Id="209" Count="4" />
      <LineId Id="248" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="249" Count="26" />
      <LineId Id="214" Count="0" />
      <LineId Id="216" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_GlobalChainProtection_EPS">
      <LineId Id="471" Count="60" />
      <LineId Id="593" Count="0" />
      <LineId Id="532" Count="12" />
      <LineId Id="592" Count="0" />
      <LineId Id="545" Count="46" />
      <LineId Id="467" Count="1" />
      <LineId Id="354" Count="0" />
      <LineId Id="469" Count="0" />
      <LineId Id="355" Count="59" />
      <LineId Id="465" Count="0" />
      <LineId Id="415" Count="12" />
      <LineId Id="466" Count="0" />
      <LineId Id="428" Count="36" />
      <LineId Id="1" Count="0" />
      <LineId Id="470" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_GlobalChainProtection_MPS">
      <LineId Id="361" Count="59" />
      <LineId Id="482" Count="2" />
      <LineId Id="423" Count="11" />
      <LineId Id="485" Count="2" />
      <LineId Id="437" Count="44" />
      <LineId Id="356" Count="2" />
      <LineId Id="232" Count="0" />
      <LineId Id="359" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="235" Count="2" />
      <LineId Id="240" Count="11" />
      <LineId Id="260" Count="43" />
      <LineId Id="354" Count="0" />
      <LineId Id="304" Count="13" />
      <LineId Id="355" Count="0" />
      <LineId Id="318" Count="35" />
      <LineId Id="1" Count="0" />
      <LineId Id="360" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_InitCompensationData">
      <LineId Id="206" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="161" Count="2" />
      <LineId Id="18" Count="0" />
      <LineId Id="211" Count="1" />
      <LineId Id="246" Count="0" />
      <LineId Id="250" Count="0" />
      <LineId Id="252" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="249" Count="0" />
      <LineId Id="253" Count="0" />
      <LineId Id="245" Count="0" />
      <LineId Id="20" Count="3" />
      <LineId Id="26" Count="1" />
      <LineId Id="329" Count="2" />
      <LineId Id="328" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="43" Count="2" />
      <LineId Id="332" Count="1" />
      <LineId Id="47" Count="0" />
      <LineId Id="59" Count="3" />
      <LineId Id="334" Count="1" />
      <LineId Id="64" Count="0" />
      <LineId Id="72" Count="4" />
      <LineId Id="213" Count="0" />
      <LineId Id="215" Count="2" />
      <LineId Id="220" Count="1" />
      <LineId Id="224" Count="1" />
      <LineId Id="337" Count="2" />
      <LineId Id="336" Count="0" />
      <LineId Id="226" Count="3" />
      <LineId Id="231" Count="0" />
      <LineId Id="340" Count="1" />
      <LineId Id="233" Count="3" />
      <LineId Id="238" Count="0" />
      <LineId Id="342" Count="1" />
      <LineId Id="240" Count="4" />
      <LineId Id="214" Count="0" />
      <LineId Id="164" Count="1" />
      <LineId Id="254" Count="0" />
      <LineId Id="300" Count="0" />
      <LineId Id="278" Count="1" />
      <LineId Id="281" Count="3" />
      <LineId Id="346" Count="2" />
      <LineId Id="344" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="349" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="302" Count="2" />
      <LineId Id="313" Count="1" />
      <LineId Id="308" Count="1" />
      <LineId Id="352" Count="2" />
      <LineId Id="350" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="355" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="301" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="389" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="326" Count="0" />
      <LineId Id="317" Count="0" />
      <LineId Id="319" Count="3" />
      <LineId Id="356" Count="3" />
      <LineId Id="318" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="323" Count="1" />
      <LineId Id="360" Count="1" />
      <LineId Id="129" Count="0" />
      <LineId Id="363" Count="25" />
      <LineId Id="130" Count="0" />
      <LineId Id="392" Count="5" />
      <LineId Id="399" Count="11" />
      <LineId Id="412" Count="4" />
      <LineId Id="391" Count="0" />
      <LineId Id="390" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_MonitoringAllAxis">
      <LineId Id="0" Count="24" />
      <LineId Id="112" Count="7" />
      <LineId Id="25" Count="8" />
      <LineId Id="120" Count="7" />
      <LineId Id="34" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="128" Count="0" />
      <LineId Id="130" Count="7" />
      <LineId Id="129" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="37" Count="1" />
      <LineId Id="88" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="41" Count="1" />
      <LineId Id="91" Count="2" />
      <LineId Id="44" Count="1" />
      <LineId Id="94" Count="2" />
      <LineId Id="47" Count="2" />
      <LineId Id="97" Count="2" />
      <LineId Id="51" Count="1" />
      <LineId Id="100" Count="2" />
      <LineId Id="54" Count="2" />
      <LineId Id="103" Count="2" />
      <LineId Id="58" Count="1" />
      <LineId Id="106" Count="2" />
      <LineId Id="111" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="184" Count="42" />
      <LineId Id="183" Count="0" />
      <LineId Id="63" Count="6" />
    </LineIds>
    <LineIds Name="UserMode.A_OneKeyToMaxGap">
      <LineId Id="499" Count="4" />
      <LineId Id="508" Count="2" />
      <LineId Id="605" Count="0" />
      <LineId Id="511" Count="27" />
      <LineId Id="595" Count="0" />
      <LineId Id="539" Count="12" />
      <LineId Id="596" Count="0" />
      <LineId Id="552" Count="1" />
      <LineId Id="564" Count="8" />
      <LineId Id="598" Count="0" />
      <LineId Id="573" Count="5" />
      <LineId Id="599" Count="0" />
      <LineId Id="579" Count="0" />
      <LineId Id="645" Count="0" />
      <LineId Id="652" Count="4" />
      <LineId Id="644" Count="0" />
      <LineId Id="657" Count="0" />
      <LineId Id="580" Count="1" />
      <LineId Id="583" Count="2" />
      <LineId Id="593" Count="0" />
      <LineId Id="600" Count="0" />
      <LineId Id="602" Count="0" />
      <LineId Id="601" Count="0" />
      <LineId Id="586" Count="4" />
      <LineId Id="603" Count="1" />
      <LineId Id="594" Count="0" />
      <LineId Id="591" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="606" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_PowerOff">
      <LineId Id="0" Count="13" />
      <LineId Id="18" Count="9" />
      <LineId Id="38" Count="0" />
      <LineId Id="28" Count="8" />
    </LineIds>
    <LineIds Name="UserMode.A_PowerOn">
      <LineId Id="0" Count="40" />
      <LineId Id="51" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="4" />
    </LineIds>
    <LineIds Name="UserMode.A_RegularMotion">
      <LineId Id="490" Count="55" />
      <LineId Id="812" Count="22" />
      <LineId Id="788" Count="0" />
      <LineId Id="546" Count="30" />
      <LineId Id="838" Count="3" />
      <LineId Id="577" Count="4" />
      <LineId Id="842" Count="3" />
      <LineId Id="582" Count="4" />
      <LineId Id="846" Count="3" />
      <LineId Id="587" Count="64" />
      <LineId Id="850" Count="23" />
      <LineId Id="652" Count="6" />
      <LineId Id="874" Count="3" />
      <LineId Id="659" Count="6" />
      <LineId Id="878" Count="3" />
      <LineId Id="666" Count="17" />
      <LineId Id="882" Count="3" />
      <LineId Id="684" Count="28" />
      <LineId Id="886" Count="3" />
      <LineId Id="713" Count="5" />
      <LineId Id="890" Count="3" />
      <LineId Id="719" Count="4" />
      <LineId Id="894" Count="3" />
      <LineId Id="724" Count="63" />
      <LineId Id="199" Count="0" />
    </LineIds>
    <LineIds Name="UserMode.A_SpectroscopyScanningMotion">
      <LineId Id="307" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="186" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="294" Count="0" />
      <LineId Id="190" Count="9" />
      <LineId Id="238" Count="0" />
      <LineId Id="242" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="244" Count="9" />
      <LineId Id="241" Count="0" />
      <LineId Id="255" Count="0" />
      <LineId Id="296" Count="0" />
      <LineId Id="257" Count="9" />
      <LineId Id="254" Count="0" />
      <LineId Id="268" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="270" Count="9" />
      <LineId Id="267" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="300" Count="2" />
      <LineId Id="305" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="1" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="304" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="8" Count="10" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="162" Count="1" />
      <LineId Id="165" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="34" Count="4" />
      <LineId Id="160" Count="1" />
      <LineId Id="168" Count="0" />
      <LineId Id="39" Count="3" />
      <LineId Id="45" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="143" Count="1" />
      <LineId Id="146" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="53" Count="3" />
      <LineId Id="306" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="88" Count="4" />
      <LineId Id="94" Count="25" />
      <LineId Id="87" Count="0" />
      <LineId Id="79" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>